<!DOCTYPE html>
<html lang="es">
<head>
    <title>An√°lisis Comparativo de Estrategias de Trading</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <!-- Chart.js for data visualization and zoom plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.min.js"></script>
    <style>
        .databank-top3 {
            background-color: rgba(20, 184, 166, 0.1); /* teal-600 with 10% opacity */
        }
        .databank-top3:hover {
            background-color: rgba(20, 184, 166, 0.2);
        }
        /* Custom font and scrollbar for a better look and feel */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for file inputs */
        .file-input-label {
            transition: all 0.2s ease-in-out;
        }
        .file-input-label:hover {
            background-color: #374151; /* gray-700 */
            border-color: #38bdf8; /* sky-400 */
        }
        /* Styles for active and inactive tabs */
        .tab-btn.active {
            border-color: #38bdf8; /* sky-400 */
            color: #e5e7eb; /* gray-200 */
            background-color: #374151; /* gray-700 */
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        /* Sortable table header style */
        .sortable {
            cursor: pointer;
            transition: color 0.2s ease-in-out;
        }
        .sortable:hover {
            color: #38bdf8;
        }
        .sortable[data-order="asc"]::after {
            content: ' ‚ñ≤';
            font-size: 0.7em;
        }
        .sortable[data-order="desc"]::after {
            content: ' ‚ñº';
            font-size: 0.7em;
        }
        .corr-cell {
            color: white;
            font-weight: bold;
            text-align: center;
            padding: 0.75rem;
            font-size: 0.875rem;
        }
        .corr-header {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            white-space: nowrap;
            padding: 0.5rem;
            text-align: left;
            font-weight: 600;
        }
        .spinner {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        /* Modal Styles */
        .modal-backdrop {
            transition: opacity 0.3s ease;
        }
        .modal-content {
            transition: transform 0.3s ease;
        }
        .feature-portfolio-btn.featured, .compare-original-btn.active {
            color: #fbbf24; /* amber-400 */
        }
        /* View Manager Styles */
        .view-column-item {
            cursor: grab;
        }
        .view-column-item:active {
            cursor: grabbing;
            background-color: #374151;
        }
        .copyable-strategy:hover {
            background-color: #374151;
            cursor: pointer;
        }
        .chart-action-item.active {
            background-color: #0ea5e9; /* sky-500 */
            color: white;
            font-weight: 600;
        }
        /* Smooth scrolling */
        html {
            scroll-behavior: smooth;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

<div class="container mx-auto max-w-7xl p-4 sm:p-6 lg:p-8">
    
    <!-- Header Section -->
    <header class="mb-8 text-center">
        <h1 class="text-4xl sm:text-5xl font-bold text-sky-400 mb-2">Dashboard Comparativo de Estrategias</h1>
        <p class="text-lg text-gray-400">Sube m√∫ltiples estrategias y comp√°ralas contra un activo para encontrar la mejor.</p>
    </header>

    <!-- Page Index -->
    <div id="page-index" class="mb-8 p-4 bg-gray-800/30 rounded-lg border border-gray-700">
        <h3 class="text-lg font-semibold text-sky-400 mb-3 text-center">√çndice de Secciones</h3>
        <div class="flex flex-wrap justify-center gap-x-6 gap-y-2 text-sm">
            <a href="#controls-section" class="hover:text-sky-400 transition-colors">üîº Controles y Carga</a>
            <a href="#databank-section" class="hover:text-sky-400 transition-colors">üè¶ DataBank</a>
            <a href="#saved-portfolios-section" class="hover:text-sky-400 transition-colors">üíæ Mis Portafolios</a>
            <a href="#portfolio-comparison-chart-section" class="hover:text-sky-400 transition-colors">üìä Gr√°fico Comparativo</a>
            <a href="#featured-portfolio-section" class="hover:text-sky-400 transition-colors">‚≠ê Portafolio Destacado</a>
            <a href="#results" class="hover:text-sky-400 transition-colors">üìà Pesta√±as de An√°lisis</a>
        </div>
    </div>

    <!-- Controls Section -->
    <div id="controls-section" class="bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-6 mb-8 border border-gray-700">
        <div class="grid grid-cols-1 md:grid-cols-5 gap-6 items-end">
             <!-- Optimization Metric Select -->
             <div>
                <label for="optimization-metric-select" class="block text-sm font-semibold text-teal-400 mb-2">Optimizar M√©trica</label>
                <select id="optimization-metric-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                    <option value="profitFactor">Profit Factor</option>
                    <option value="profitMaxDD_Ratio">Ret/DD</option>
                    <option value="monthlyProfitToDollarDD">Ratio Profit Mes / DD($)</option>
                    <option value="upi">UPI</option>
                    <option value="sortinoRatio">Sortino</option>
                    <option value="sharpeRatio">Coef. Sharpe</option>
                    <option value="captureRatio">Capture Ratio</option>
                    <option value="monthlyAvgProfit">Profit Prom./Mes</option>
                    <option value="maxConsecutiveLosingMonths">Meses Cons. P√©rdida (Max)</option>
                    <option value="winningPercentage">Win %</option>
                    <option value="avgWin">Avg. Win</option>
                    <option value="avgLoss">Avg. Loss</option>
                    <option value="maxDrawdownInDollars">Max DD ($)</option>
                    <option value="maxDrawdown">Max Drawdown (%)</option>
                    <option value="maxStagnationTrades">Stagnation (trades)</option>
                    <option value="maxConsecutiveLosses">P√©rdidas Consecutivas</option>
                    <option value="maxConsecutiveWins">Ganadas Consecutivas</option>
                    <option value="upsideCapture">Upside Capture</option>
                    <option value="totalTrades">N√∫mero de Trades</option>
                    <option value="maxStagnationDays">Stagnation (d√≠as)</option>
                    <option value="sqn">SQN</option>
                    <option value="downsideCapture">Downside Capture</option>
                </select>
             </div>
             <!-- Optimization Goal Select -->
             <div>
                <label for="optimization-goal-select" class="block text-sm font-semibold text-teal-400 mb-2">Objetivo</label>
                <select id="optimization-goal-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                    <option value="maximize">Maximizar</option>
                    <option value="minimize">Minimizar</option>
                </select>
             </div>
             <!-- Correlation Filter -->
             <div>
                <label for="correlation-filter" class="block text-sm font-semibold text-teal-400 mb-2">Max. Correlaci√≥n</label>
                <input type="number" id="correlation-filter" value="0.3" step="0.1" min="-1" max="1" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
            </div>
           <!-- Min Weight Filter -->
           <div>
                <label for="min-weight-filter" class="block text-sm font-semibold text-teal-400 mb-2">Min. Peso (%)</label>
                <input type="number" id="min-weight-filter" value="10" step="1" min="0" max="100" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
           </div>
             <!-- Find Portfolios Button -->
             <button id="findDatabankPortfoliosBtn" class="w-full bg-teal-500 hover:bg-teal-600 disabled:bg-teal-800 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg transform transition-transform duration-200 hover:scale-105">
                 <div id="findBestBtnText">
                    <span class="block">üîç Buscar en DataBank</span>
                    <span id="find-mode-indicator" class="text-xs text-teal-200 font-normal">(B√∫squeda Global)</span>
                 </div>
                 <span id="findBestBtnSpinner" class="hidden">
                     <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                     Buscando...
                 </span>
             </button>
             <!-- Analyze & Reset Buttons -->
             <div class="md:col-span-1 flex flex-col space-y-3">
                  <button id="analyzeBtn" class="w-full bg-sky-500 hover:bg-sky-600 disabled:bg-sky-800 disabled:text-gray-400 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-lg shadow-lg transform transition-transform duration-200 hover:scale-105">
                      <span id="analyzeBtnText">Analizar</span>
                      <span id="analyzeBtnSpinner" class="hidden">
                          <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                          Procesando...
                      </span>
                  </button>
                  <div class="grid grid-cols-2 gap-2">
                      <button id="exportBtn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-2 rounded-lg text-sm">Exportar</button>
                      <label for="importFile" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-2 rounded-lg text-sm text-center cursor-pointer">Importar</label>
                      <input type="file" id="importFile" class="hidden" accept=".json">
                  </div>
                   <button id="resetBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transform transition-transform duration-200 hover:scale-105">
                       Limpiar
                  </button>
             </div>
        </div>

        <div class="mt-6 border-t border-gray-700 pt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 items-start">
            <!-- Strategies File Input -->
            <div>
                <label for="tradesFiles" class="file-input-label flex flex-col items-center justify-center w-full h-full p-4 border-2 border-dashed border-gray-600 rounded-lg cursor-pointer">
                    <div class="text-center">
                        <svg class="mx-auto h-12 w-12 text-gray-500" stroke="currentColor" fill="none" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                        <span class="mt-2 block text-sm font-semibold text-sky-400">Subir Estrategias</span>
                        <span class="mt-1 block text-xs text-gray-400">(Puedes seleccionar varios)</span>
                    </div>
                </label>
                <input id="tradesFiles" type="file" class="hidden" accept=".csv" multiple>
                <div id="tradesFilesList" class="mt-2 text-sm text-gray-400 space-y-1"></div>
            </div>

            <!-- Benchmark File Input -->
            <div>
                <label for="benchmarkFile" class="file-input-label flex flex-col items-center justify-center w-full h-full p-4 border-2 border-dashed border-gray-600 rounded-lg cursor-pointer">
                        <div class="text-center">
                            <svg class="mx-auto h-12 w-12 text-gray-500" stroke="currentColor" fill="none" viewBox="0 0 24 24" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" /></svg>
                            <span class="mt-2 block text-sm font-semibold text-sky-400">Subir Activo</span>
                            <span id="benchmarkFileName" class="mt-1 block text-xs text-gray-400">(date, price)</span>
                        </div>
                </label>
                        <input id="benchmarkFile" type="file" class="hidden" accept=".csv">
            </div>

            <!-- Analysis Mode Dropdown -->
            <div class="flex flex-col justify-center h-full space-y-3">
                <label for="analysis-mode-select" class="block text-sm font-semibold text-sky-400 text-center mb-2">Filtrar Tiempo de An√°lisis</label>
                <select id="analysis-mode-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2.5">
                    <option value="-1">An√°lisis Completo</option>
                </select>
            </div>
        </div>
        
        <!-- Error Message Area -->
        <div id="error-message" class="hidden mt-4 text-center bg-red-900/50 border border-red-500 text-red-300 px-4 py-3 rounded-lg" role="alert"></div>
        <!-- Best Portfolios Results Area -->
        
        <!-- Saved Portfolios Area -->
        <div id="saved-portfolios-container" class="hidden mt-6"></div>

    </div>

    <div id="databank-section" class="hidden mt-8 bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-6 border border-gray-700">
        <div class="absolute top-4 right-4">
            <a href="#controls-section" class="text-xs text-gray-400 hover:text-sky-400">üîº Volver al √çndice</a>
        </div>
                <div class="flex flex-wrap justify-between items-center mb-4 gap-4">
            <div class="flex items-center gap-4">
                <h2 class="text-2xl font-bold text-teal-400">DataBank de optimizacion</h2>
                <div class="flex items-center gap-2">
                    <select id="view-selector" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 p-1.5"></select>
                    <button id="manage-views-btn" class="p-1.5 bg-gray-600 hover:bg-gray-700 rounded-lg" title="Gestionar Vistas">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z" /></svg>
                    </button>
                </div>
            </div>
            <div>
                <label for="databank-size" class="text-sm text-gray-400 mr-2">Tama√±o DataBank:</label>
                <input type="number" id="databank-size" value="20" min="10" max="500" step="10" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-20 p-1.5">
            </div>
            <div id="databank-status" class="w-full sm:w-auto text-center text-gray-300 font-mono"></div>
            <div class="flex gap-2">
                <button id="pause-search-btn" class="w-24 bg-amber-500 hover:bg-amber-600 text-white font-bold py-2 px-3 rounded-lg text-sm">Pausar</button>
                <button id="stop-search-btn" class="w-24 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-lg text-sm">Detener</button>
                <button id="clear-databank-btn" class="w-24 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-3 rounded-lg text-sm">Limpiar</button>
            </div>
        </div>
                <div id="databank-table-container" class="max-h-96 overflow-y-auto overflow-x-auto rounded-lg border border-gray-700">
            <table class="w-full text-sm text-left">
                <thead class="bg-gray-700 text-xs text-gray-400 uppercase sticky top-0" id="databank-table-header">
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† <tr>
                        <!-- Header generated by JS -->
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† </tr>
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† </thead>
                <tbody id="databank-table-body" class="divide-y divide-gray-700">
                                        <tr id="databank-empty-row">
                        <td colspan="8" class="p-8 text-center text-gray-500">
                            Inicia una b√∫squeda para poblar el DataBank.
                        </td>
                    </tr>
                </tbody>
            </table>
    	</div>
                <div class="mt-4 flex justify-end">
            <button id="databank-save-selected-btn" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg">
                Guardar Seleccionados
            </button>
        </div>
    </div>

    <!-- Saved Portfolios Section -->
    <div id="saved-portfolios-section" class="hidden mt-8 bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-6 border border-gray-700">
        <div class="absolute top-4 right-4">
            <a href="#controls-section" class="text-xs text-gray-400 hover:text-sky-400">üîº Volver al √çndice</a>
        </div>
        <h2 class="text-2xl font-bold text-sky-400 mb-4">Mis Portafolios Guardados</h2>
        <div class="max-h-96 overflow-y-auto rounded-lg border border-gray-700">
            <table class="w-full text-sm text-left">
                <thead id="saved-portfolios-header" class="bg-gray-700 text-xs text-gray-400 uppercase sticky top-0">
                    <!-- Header will be generated by JavaScript -->
                </thead>
                <tbody id="saved-portfolios-body" class="divide-y divide-gray-700">
                    <!-- Body will be generated by JavaScript -->
                </tbody>
            </table>
        </div>
        <div class="flex flex-wrap justify-between items-center mt-4 gap-4">
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2">
                    <select id="saved-view-selector" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 p-1.5"></select>
                    <button id="saved-manage-views-btn" class="p-1.5 bg-gray-600 hover:bg-gray-700 rounded-lg" title="Gestionar Vistas">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M5 4a1 1 0 00-2 0v7.268a2 2 0 000 3.464V16a1 1 0 102 0v-1.268a2 2 0 000-3.464V4zM11 4a1 1 0 10-2 0v1.268a2 2 0 000 3.464V16a1 1 0 102 0V8.732a2 2 0 000-3.464V4zM16 3a1 1 0 011 1v7.268a2 2 0 010 3.464V16a1 1 0 11-2 0v-1.268a2 2 0 010-3.464V4a1 1 0 011-1z" /></svg>
                    </button>
                </div>
                <!-- Risk Normalization Panel -->
                <div class="ml-4 bg-gray-900/50 p-2 rounded-lg border border-gray-600 flex items-center gap-4">
                    <label for="normalize-risk-checkbox" class="flex items-center space-x-2 cursor-pointer">
                        <input type="checkbox" id="normalize-risk-checkbox" class="form-checkbox h-4 w-4 bg-gray-700 border-gray-600 rounded text-sky-500 focus:ring-sky-600">
                        <span class="text-sm font-semibold text-sky-400">Normalizar Riesgo</span>
                    </label>
                    <div id="risk-normalization-controls" class="hidden flex items-center gap-2">
                        <label for="target-max-dd" class="block text-xs font-semibold text-gray-300">MaxDD Obj:</label>
                        <input type="number" id="target-max-dd" value="1000" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-24 p-1.5 text-center">
                    </div>
                </div>
            </div>
            <span id="saved-portfolios-count" class="text-sm text-gray-400 bg-gray-700 px-3 py-1 rounded-full">0 portafolios</span>
        </div>
    </div>

    <!-- Portfolio Comparison Chart Section -->
    <div id="portfolio-comparison-chart-section" class="hidden mt-8">
        <div class="absolute top-4 right-4">
            <a href="#controls-section" class="text-xs text-gray-400 hover:text-sky-400">üîº Volver al √çndice</a>
        </div>
        <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-6 border border-gray-700">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-white">Curvas de Equity (Portafolios Guardados)</h2>
                <div id="chart-actions-group" class="flex items-center border border-gray-600 rounded-lg bg-gray-800 text-gray-300">
                    <button data-action="destacar" class="chart-action-item px-3 py-1.5 text-xs font-medium rounded-l-md active">Destacar</button>
                    <button data-action="editar" class="chart-action-item px-3 py-1.5 text-xs font-medium border-x border-gray-600">Editar</button>
                    <button data-action="ocultar" class="chart-action-item px-3 py-1.5 text-xs font-medium rounded-r-md">Ocultar/Mostrar</button>
                </div>
            </div>
            <div class="h-96"><canvas id="portfolioEquityChart"></canvas></div>
        </div>
    </div>


        <!-- Featured Portfolio Section -->
    <div id="featured-portfolio-section" class="hidden mb-8 relative">
        <div class="absolute top-4 right-4 z-10">
            <a href="#controls-section" class="text-xs text-gray-400 hover:text-sky-400">üîº Volver al √çndice</a>
        </div>
    </div>


    <!-- Results Section -->
    <div id="results" class="hidden">
        <a href="#controls-section" class="text-xs text-gray-400 hover:text-sky-400 float-right mb-2">üîº Volver al √çndice</a>
        <!-- Tab Navigation -->
        <div id="tab-container" class="mb-4 border-b border-gray-700">
            <div class="flex justify-between items-center">
                <nav id="tab-nav" class="-mb-px flex space-x-4 overflow-x-auto" aria-label="Tabs"></nav>
                <button id="redraw-charts-btn" class="ml-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg text-sm whitespace-nowrap">üìä Dibujar Gr√°ficos</button>
            </div>
        </div>

        <!-- Tab Content Area -->
        <div id="tab-content-area"></div>
    </div>
</div>

<!-- Floating Quick Index -->
<div id="quick-index" class="fixed bottom-4 right-4 z-50">
    <div id="quick-index-content" class="hidden bg-gray-800/80 backdrop-blur-sm border border-gray-600 rounded-lg shadow-lg p-4 w-64 mb-2 transition-all duration-300 ease-in-out">
        <h4 class="font-bold text-sky-400 mb-2">√çndice R√°pido</h4>
        <ul class="space-y-2 text-sm">
            <li><a href="#controls-section" class="hover:text-sky-400 block">üîº Controles y Carga</a></li>
            <li><a href="#databank-section" class="hover:text-sky-400 block">üè¶ DataBank</a></li>
            <li><a href="#saved-portfolios-section" class="hover:text-sky-400 block">üíæ Mis Portafolios</a></li>
            <li><a href="#portfolio-comparison-chart-section" class="hover:text-sky-400 block">üìä Gr√°fico Comparativo</a></li>
            <li><a href="#featured-portfolio-section" class="hover:text-sky-400 block">‚≠ê Portafolio Destacado</a></li>
            <li><a href="#results" class="hover:text-sky-400 block">üìà Pesta√±as de An√°lisis</a></li>
        </ul>
    </div>
    <button id="toggle-quick-index" class="w-14 h-14 bg-sky-600 hover:bg-sky-700 text-white rounded-full flex items-center justify-center shadow-lg float-right" title="Mostrar/Ocultar √çndice">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h7" />
        </svg>
    </button>
</div>

<!-- Optimization Modal -->
<div id="optimization-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
    <div id="optimization-modal-backdrop" class="fixed inset-0 bg-black/70 modal-backdrop opacity-0"></div>
    <div id="optimization-modal-content" class="modal-content bg-gray-800 rounded-lg shadow-2xl w-full max-w-2xl m-4 border border-gray-700 transform scale-95 opacity-0 flex flex-col max-h-[90vh]">
        <!-- Header -->
        <div class="p-6 border-b border-gray-700 flex-shrink-0">
            <div class="flex justify-between items-center">
                <h2 id="optimization-modal-title" class="text-2xl font-bold text-white"></h2>
                <button id="close-optimization-modal-btn" class="text-gray-400 hover:text-white">&times;</button>
            </div>
        </div>
        
        <!-- Scrollable Content -->
        <div class="p-6 overflow-y-auto">
            <p id="optimization-portfolio-name" class="text-sky-300 font-semibold mb-4"></p>
            
            <div id="optimization-results-container" class="hidden mb-6"></div>
            
            <div id="optimization-setup-container" class="hidden pt-6 border-t border-gray-600">
                <h3 class="text-xl font-bold text-white mb-4">Buscar Pesos √ìptimos</h3>
                <div class="space-y-4">
                    <div>
                        <label for="simulations-count" class="block text-sm font-semibold text-gray-300 mb-1">N√∫mero de Simulaciones</label>
                        <input type="number" id="simulations-count" value="1000" min="100" max="50000" step="100" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                    </div>
                    <div>
                        <label for="optimization-target-metric" class="block text-sm font-semibold text-gray-300 mb-1">M√©trica Objetivo</label>
                        <select id="optimization-target-metric" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5"></select>
                    </div>
                    <div>
                        <label for="optimization-target-goal" class="block text-sm font-semibold text-gray-300 mb-1">Objetivo</label>
                        <select id="optimization-target-goal" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                            <option value="maximize">Maximizar</option>
                            <option value="minimize">Minimizar</option>
                        </select>
                    </div>
                </div>

                <div class="mt-6">
                    <button id="start-single-optimization-btn" class="w-full bg-teal-500 hover:bg-teal-600 disabled:bg-teal-800 text-white font-bold py-3 px-4 rounded-lg">
                        <span id="start-optimization-btn-text">Iniciar B√∫squeda</span>
                        <span id="start-optimization-btn-spinner" class="hidden">
                            <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                            Buscando...
                        </span>
                    </button>
                </div>
            </div>

        </div>
    </div>
</div>

<!-- View Manager Modal -->
<div id="view-manager-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
    <div id="view-manager-backdrop" class="fixed inset-0 bg-black/70 modal-backdrop opacity-0"></div>
    <div id="view-manager-content" class="modal-content bg-gray-800 rounded-lg shadow-2xl w-full max-w-3xl m-4 border border-gray-700 transform scale-95 opacity-0 flex flex-col max-h-[90vh]">
        <div class="p-4 border-b border-gray-700 flex justify-between items-center">
            <h2 class="text-xl font-bold text-white">Gestionar Vistas del DataBank</h2>
            <button id="close-view-manager-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
        </div>
        <div class="p-4 grid grid-cols-2 gap-4 overflow-y-auto">
            <div>
                <h3 class="font-semibold mb-2">Columnas Visibles (Arrastra para ordenar)</h3>
                <ul id="visible-columns-list" class="bg-gray-900/50 p-2 rounded-lg border border-gray-600 min-h-[200px] space-y-1">
                    <!-- JS will populate this -->
                </ul>
            </div>
            <div>
                <h3 class="font-semibold mb-2">Columnas Ocultas</h3>
                <ul id="hidden-columns-list" class="bg-gray-900/50 p-2 rounded-lg border border-gray-600 min-h-[200px] space-y-1">
                    <!-- JS will populate this -->
                </ul>
            </div>
        </div>
        <div class="p-4 border-t border-gray-700 mt-auto">
            <div class="flex justify-between items-center gap-4">
                <div class="flex-grow flex gap-2">
                    <input type="text" id="view-name-input" placeholder="Nombre de la nueva vista..." class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block w-full p-2">
                    <button id="save-view-btn" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-lg text-sm">Guardar Vista</button>
                </div>
                <div class="flex gap-2">
                    <button id="delete-view-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg text-sm">Eliminar Vista</button>
                    <button id="apply-view-btn" class="bg-teal-500 hover:bg-teal-600 text-white font-bold py-2 px-4 rounded-lg text-sm">Aplicar</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Chart Click Modal -->
<div id="chart-click-modal" class="fixed inset-0 z-50 hidden items-center justify-center">
    <div id="chart-click-modal-backdrop" class="fixed inset-0 bg-black/70 modal-backdrop opacity-0"></div>
    <div id="chart-click-modal-content" class="modal-content bg-gray-800 rounded-lg shadow-2xl w-full max-w-lg m-4 border border-gray-700 transform scale-95 opacity-0">
        <div class="p-6">
            <h3 id="chart-click-modal-title" class="text-lg font-bold text-white mb-4">Acciones del Portafolio</h3>
            <div class="space-y-4">
                <label class="flex items-center space-x-3 text-gray-300">
                    <input type="checkbox" id="feature-portfolio-checkbox" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 rounded text-sky-500 focus:ring-sky-600">
                    <span>Establecer como portafolio destacado</span>
                </label>
                <label class="flex items-center space-x-3 text-gray-300">
                    <input type="checkbox" id="delete-others-checkbox" class="form-checkbox h-5 w-5 bg-gray-700 border-gray-600 rounded text-red-500 focus:ring-red-600">
                    <span class="text-red-300">Eliminar TODOS los dem√°s portafolios guardados</span>
                </label>
            </div>
            <div class="mt-6 flex justify-end gap-4">
                <button id="chart-click-cancel-btn" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-lg text-sm font-semibold">Cancelar</button>
                <button id="chart-click-confirm-btn" class="px-4 py-2 bg-sky-600 hover:bg-sky-700 rounded-lg text-sm font-semibold">Confirmar</button>
            </div>
        </div>
    </div>
</div>


<script type="module">
document.addEventListener('DOMContentLoaded', () => {
    // DOM Elements
    const tradesFileInput = document.getElementById('tradesFiles');
    const benchmarkFileInput = document.getElementById('benchmarkFile');
    const tradesFilesListEl = document.getElementById('tradesFilesList');
    const benchmarkFileNameEl = document.getElementById('benchmarkFileName');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const resetBtn = document.getElementById('resetBtn');
    const resultsDiv = document.getElementById('results');
    const errorMessageDiv = document.getElementById('error-message');
    const tabNav = document.getElementById('tab-nav');
    const tabContentArea = document.getElementById('tab-content-area');
    const analysisModeSelect = document.getElementById('analysis-mode-select');
    const redrawChartsBtn = document.getElementById('redraw-charts-btn');
    const findBestPortfoliosBtn = document.getElementById('findBestPortfoliosBtn');
    const optimizationMetricSelect = document.getElementById('optimization-metric-select');
    const normalizeRiskCheckbox = document.getElementById('normalize-risk-checkbox');
    const riskNormalizationControls = document.getElementById('risk-normalization-controls');
    const optimizationGoalSelect = document.getElementById('optimization-goal-select');
    const savedPortfoliosSection = document.getElementById('saved-portfolios-section');
    const savedPortfoliosHeader = document.getElementById('saved-portfolios-header');
    const savedPortfoliosBody = document.getElementById('saved-portfolios-body');
    const savedPortfoliosCount = document.getElementById('saved-portfolios-count');
    const correlationFilterInput = document.getElementById('correlation-filter');
    const portfolioComparisonChartSection = document.getElementById('portfolio-comparison-chart-section');
    const exportBtn = document.getElementById('exportBtn');
    const importFile = document.getElementById('importFile');
    const featuredPortfolioSection = document.getElementById('featured-portfolio-section');
    // Databank Elements
    const databankSizeInput = document.getElementById('databank-size');
    const findDatabankPortfoliosBtn = document.getElementById('findDatabankPortfoliosBtn');
    const databankSection = document.getElementById('databank-section');
    const databankStatus = document.getElementById('databank-status');
    const pauseSearchBtn = document.getElementById('pause-search-btn');
    const stopSearchBtn = document.getElementById('stop-search-btn');
    const clearDatabankBtn = document.getElementById('clear-databank-btn');
    const databankTableBody = document.getElementById('databank-table-body');
    const databankEmptyRow = document.getElementById('databank-empty-row');
    const databankSaveSelectedBtn = document.getElementById('databank-save-selected-btn');
    const databankTableHeader = document.getElementById('databank-table-header');
    const databankMetricHeader = document.getElementById('databank-metric-header');

    // View Manager Elements
    const manageViewsBtn = document.getElementById('manage-views-btn');
    const viewManagerModal = document.getElementById('view-manager-modal');
    const closeViewManagerBtn = document.getElementById('close-view-manager-btn');
    const viewManagerBackdrop = document.getElementById('view-manager-backdrop');
    const viewManagerContent = document.getElementById('view-manager-content');
    const viewSelector = document.getElementById('view-selector');
    const savedViewSelector = document.getElementById('saved-view-selector');

    // Optimization Modal Elements
    const optimizationModal = document.getElementById('optimization-modal');
    const optimizationModalBackdrop = document.getElementById('optimization-modal-backdrop');
    const optimizationModalContent = document.getElementById('optimization-modal-content');
    const closeOptimizationModalBtn = document.getElementById('close-optimization-modal-btn');
    const startSingleOptimizationBtn = document.getElementById('start-single-optimization-btn');
    const optimizationPortfolioNameEl = document.getElementById('optimization-portfolio-name');
    const optimizationTargetMetricSelect = document.getElementById('optimization-target-metric');
    const optimizationTargetGoalSelect = document.getElementById('optimization-target-goal');
    const optimizationResultsContainer = document.getElementById('optimization-results-container');
    const simulationsCountInput = document.getElementById('simulations-count');
    const optimizationSetupContainer = document.getElementById('optimization-setup-container');
    const optimizationModalTitle = document.getElementById('optimization-modal-title');

    // Chart Click Modal elements
    const chartClickModal = document.getElementById('chart-click-modal');
    const chartClickModalBackdrop = document.getElementById('chart-click-modal-backdrop');
    const chartClickModalContent = document.getElementById('chart-click-modal-content');
    const chartClickCancelBtn = document.getElementById('chart-click-cancel-btn');
    const chartClickConfirmBtn = document.getElementById('chart-click-confirm-btn');

    // Quick Index Elements
    const toggleQuickIndexBtn = document.getElementById('toggle-quick-index');
    const quickIndexContent = document.getElementById('quick-index-content');


    
    // State
    let chartInstances = {};
    let loadedStrategyFiles = [];
    let rawBenchmarkData = null;
    let rawStrategiesData = [];
    let selectedPortfolioIndices = new Set();
    let savedPortfolios = [];
    let featuredPortfolioIndex = null;
    let currentOptimizationData = {};
    let portfolioActionTargetIndex = null;
    let comparisonPortfolioIndex = null;
    let databankPortfolios = [];
    let savedPortfoliosSortConfig = { key: 'savedIndex', order: 'asc' };
    let nextPortfolioId = 0;
    let selectedRows = { databank: [], saved: [] };
    let isSearchPaused = false;
    let isSearchStopped = false;

    const ALL_METRICS = {
        name: { label: 'Portafolio', class: 'p-2 text-left align-bottom' },
        metricValue: { label: 'M√©trica Optimizada', class: 'p-2 text-center' },
        profitFactor: { label: 'Profit Factor', class: 'p-2 text-center' },
        sortinoRatio: { label: 'Ratio Sortino', class: 'p-2 text-center' },
        upi: { label: 'UPI', class: 'p-2 text-center' },
        sharpeRatio: { label: 'Ratio Sharpe', class: 'p-2 text-center' },
        captureRatio: { label: 'Capture Ratio', class: 'p-2 text-center' },
        maxDrawdown: { label: 'Max Drawdown %', class: 'p-2 text-center' },
        maxDrawdownInDollars: { label: 'Max Drawdown $', class: 'p-2 text-center' },
        monthlyAvgProfit: { label: 'Profit / Mes', class: 'p-2 text-center' },
        profitMaxDD_Ratio: { label: 'Ret/DD', class: 'p-2 text-center' },
        monthlyProfitToDollarDD: { label: 'Profit/Mes / DD$', class: 'p-2 text-center' },
        maxConsecutiveLosingMonths: { label: 'Max Meses P√©rdida', class: 'p-2 text-center' },
        winningPercentage: { label: 'Win %', class: 'p-2 text-center' },
        maxStagnationTrades: { label: 'Stagnation (Trades)', class: 'p-2 text-center' },
        totalTrades: { label: 'Num. Trades', class: 'p-2 text-center' },
        maxStagnationDays: { label: 'Stagnation (D√≠as)', class: 'p-2 text-center' },
        sqn: { label: 'SQN', class: 'p-2 text-center' },
    };

    let tableViews = {
        databank: {
            'default': { name: 'Vista por Defecto', columns: ['name', 'metricValue', 'profitFactor', 'sortinoRatio', 'maxDrawdown', 'monthlyAvgProfit', 'maxConsecutiveLosingMonths'] },
            'risk': { name: 'Vista de Riesgo', columns: ['name', 'maxDrawdown', 'maxDrawdownInDollars', 'maxConsecutiveLosingMonths', 'sortinoRatio', 'upi'] },
            'profit': { name: 'Vista de Beneficio', columns: ['name', 'profitFactor', 'monthlyAvgProfit', 'profitMaxDD_Ratio', 'monthlyProfitToDollarDD'] }
        },
        saved: {
            'default': { name: 'Vista por Defecto', columns: ['name', 'profitFactor', 'sortinoRatio', 'upi', 'maxDrawdown', 'monthlyAvgProfit', 'maxConsecutiveLosingMonths'] },
            'risk': { name: 'Vista de Riesgo', columns: ['name', 'maxDrawdown', 'maxDrawdownInDollars', 'maxConsecutiveLosingMonths', 'sortinoRatio', 'upi'] },
            'profit': { name: 'Vista de Beneficio', columns: ['name', 'profitFactor', 'monthlyAvgProfit', 'profitMaxDD_Ratio', 'monthlyProfitToDollarDD'] }
        }
    };
    let activeViews = { databank: 'default', saved: 'default' };
    let currentEditingViewSet = 'databank'; // 'databank' or 'saved'

    const SELECTION_COLORS = [
        'bg-sky-900/60',
        'bg-purple-900/60',
        'bg-emerald-900/60',
        'bg-pink-900/60',
        'bg-amber-900/60'
    ];

    let databankSortConfig = { key: 'metricValue', order: 'desc' }; // <-- A√ëADE ESTA L√çNEA

    const STRATEGY_COLORS = ['#38bdf8', '#a78bfa', '#f472b6', '#4ade80', '#fb923c', '#f87171', '#818cf8', '#67e8f9', '#d8b4fe', '#f9a8d4'];

    // --- UTILITY FUNCTIONS ---
    const toggleLoading = (isLoading, buttonId, textId, spinnerId) => {
        const btn = document.getElementById(buttonId);
        const btnText = document.getElementById(textId);
        const btnSpinner = document.getElementById(spinnerId);
        if (btnText && btnSpinner && btn) {
            btnText.classList.toggle('hidden', isLoading);
            btnSpinner.classList.toggle('hidden', !isLoading);
            btn.disabled = isLoading;
        }
    };


    const displayError = (message) => {
        errorMessageDiv.textContent = `Error: ${message}`;
        errorMessageDiv.classList.remove('hidden');
    };
    
    const hideError = () => errorMessageDiv.classList.add('hidden');

    const parseCsv = (file) => {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                header: true, skipEmptyLines: true, dynamicTyping: true,
                transformHeader: h => {
                    const header = h.trim().toLowerCase();
                    const map = { 'open time': 'entry_date', 'close time': 'exit_date', 'profit/loss': 'pnl', 'time': 'date', 'fecha': 'date', 'gmt time': 'date', 'timestamp': 'date', 'datetime': 'date', 'close': 'price', 'precio': 'price', 'cierre': 'price', 'last': 'price', 'value': 'price', 'open price': 'price', 'close price': 'price' };
                    return map[header] || header;
                },
                complete: (results) => {
                    if (results.errors.length) return reject(new Error(`Error al parsear ${file.name}: ${results.errors[0].message}`));
                    if (results.data.length === 0) return reject(new Error(`El archivo ${file.name} est√° vac√≠o.`));
                    const data = results.data.map(row => {
                        if (row.hasOwnProperty('entry_date') && !row.hasOwnProperty('date')) row.date = row.entry_date;
                        if (!row.hasOwnProperty('price')) {
                            if (row.hasOwnProperty('close price')) row.price = row['close price'];
                            else if (row.hasOwnProperty('open price')) row.price = row['open price'];
                        }
                        return row;
                    });
                    resolve(data);
                },
                error: (error) => reject(new Error(`No se pudo leer el archivo ${file.name}: ${error.message}`))
            });
        });
    };

    const destroyChart = (canvasId) => {
        if (chartInstances[canvasId]) {
            chartInstances[canvasId].destroy();
            delete chartInstances[canvasId];
        }
    };
    
    const destroyAllCharts = () => {
        Object.keys(chartInstances).forEach(destroyChart);
    };

    const findDatabankPortfolios = async () => {
        hideError();
        if (rawStrategiesData.length < 2) {
            displayError("Necesitas al menos 2 estrategias cargadas para buscar portafolios.");
            return;
        }

        // Update search mode indicator based on selection
        const findModeIndicator = document.getElementById('find-mode-indicator');
        findModeIndicator.textContent = selectedPortfolioIndices.size > 0 ? '(B√∫squeda de Complementos)' : '(B√∫squeda Global)';

        // Reset state for new search
¬† ¬† ¬† ¬† databankPortfolios = [];
¬† ¬† ¬† ¬† isSearchPaused = false;
¬† ¬† ¬† ¬† isSearchStopped = false;
¬† ¬† ¬† ¬† // updateDatabankDisplay() se llama despu√©s de resetear el sort config

¬† ¬† ¬† ¬† // Show Databank section and update UI
        databankSection.classList.remove('hidden');
        databankStatus.innerHTML = `üèÅ Preparando b√∫squeda...`;
        pauseSearchBtn.disabled = false;
        stopSearchBtn.disabled = false;
        pauseSearchBtn.textContent = 'Pausar';
        // Use the new button ID here:
        toggleLoading(true, 'findDatabankPortfoliosBtn', 'findBestBtnText', 'findBestBtnSpinner');
        clearDatabankBtn.disabled = true; // Disable clear while running
        if (databankSizeInput) databankSizeInput.disabled = true; // Disable size change while running

        try {
¬† ¬† ¬† ¬† ¬† ¬† await new Promise(resolve => setTimeout(resolve, 50)); // Allow UI to update

¬† ¬† ¬† ¬† ¬† ¬† const metricToOptimizeKey = optimizationMetricSelect.value;
¬† ¬† ¬† ¬† ¬† ¬† const optimizationGoal = optimizationGoalSelect.value;
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† // --- A√ëADIDO: Resetear el sort config al de la m√©trica primaria ---
¬† ¬† ¬† ¬† ¬† ¬† databankSortConfig.key = 'metricValue';
¬† ¬† ¬† ¬† ¬† ¬† databankSortConfig.order = (optimizationGoal === 'maximize') ? 'desc' : 'asc';
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† // Limpiar indicadores de ordenamiento de la cabecera
¬† ¬† ¬† ¬† ¬† ¬† document.querySelectorAll('#databank-table-header th.sortable').forEach(th => th.removeAttribute('data-order'));
¬† ¬† ¬† ¬† ¬† ¬† // Poner el indicador en la cabecera de la m√©trica primaria
¬† ¬† ¬† ¬† ¬† ¬† const primaryMetricHeader = document.getElementById('databank-metric-header');
¬† ¬† ¬† ¬† ¬† ¬† if(primaryMetricHeader) primaryMetricHeader.dataset.order = databankSortConfig.order;
¬† ¬† ¬† ¬† ¬† ¬† // --- FIN A√ëADIDO ---
¬† ¬† ¬† ¬† ¬† ¬†¬†
¬† ¬† ¬† ¬† ¬† ¬† updateDatabankDisplay(); // <-- MOVIMOS ESTA LLAMADA AQU√ç
            const correlationThreshold = parseFloat(correlationFilterInput.value);
            const maxSize = parseInt(databankSizeInput.value, 10);
            const metricName = optimizationMetricSelect.options[optimizationMetricSelect.selectedIndex].text;

            // Update metric header in table
            if (databankMetricHeader) databankMetricHeader.textContent = metricName;

            databankStatus.innerHTML = `üîç Calculando correlaciones...`;
            await new Promise(resolve => setTimeout(resolve, 10));

            // Pre-calculate correlations to avoid doing it inside the loop
            const individualAnalyses = rawStrategiesData.map(data => processStrategyData(data, rawBenchmarkData)).filter(Boolean);
            if(individualAnalyses.length !== rawStrategiesData.length){
                displayError("Algunas estrategias no pudieron ser analizadas individualmente. Verifica los datos.");
                // Optionally handle this error more gracefully
            }
            const fullCorrelationMatrix = calculateCorrelationMatrix(individualAnalyses.map((analysis, i) => ({ analysis, originalIndex: i })));

            databankStatus.innerHTML = `üîç Generando combinaciones...`;
            await new Promise(resolve => setTimeout(resolve, 10));

            let allCombinations, totalCombinations;
            const baseIndices = Array.from(selectedPortfolioIndices);

            if (baseIndices.length > 0) {
                // --- MODO: B√öSQUEDA DE COMPLEMENTOS ---
                findModeIndicator.textContent = '(B√∫squeda de Complementos)';

                // --- RESTAURADO: Verificaci√≥n de correlaci√≥n en la selecci√≥n base ---
                if (baseIndices.length > 1) {
                    for (let i = 0; i < baseIndices.length; i++) {
                        for (let j = i + 1; j < baseIndices.length; j++) {
                            if (fullCorrelationMatrix[baseIndices[i]][baseIndices[j]] > correlationThreshold) {
                                const name1 = loadedStrategyFiles[baseIndices[i]].name.replace('.csv', '');
                                const name2 = loadedStrategyFiles[baseIndices[j]].name.replace('.csv', '');
                                const corrValue = fullCorrelationMatrix[baseIndices[i]][baseIndices[j]].toFixed(3);
                                const errorMsg = `B√∫squeda detenida. Las estrategias base seleccionadas '${name1}' y '${name2}' tienen una correlaci√≥n de ${corrValue}, que supera el m√°ximo permitido de ${correlationThreshold}.`;
                                displayError(errorMsg);
                                databankStatus.innerHTML = `‚ùå Error de correlaci√≥n base.`;
                                toggleLoading(false, 'findDatabankPortfoliosBtn', 'findBestBtnText', 'findBestBtnSpinner');
                                clearDatabankBtn.disabled = false;
                                if (databankSizeInput) databankSizeInput.disabled = false;
                                return;
                            }
                        }
                    }
                }
                // --- FIN DE LA VERIFICACI√ìN ---

                const candidateIndices = rawStrategiesData.map((_, i) => i).filter(i => !baseIndices.includes(i));
                const maxComplementSize = Math.min(candidateIndices.length, 12 - baseIndices.length);
                
                // Generador de combinaciones de candidatos
                const complementCombinations = getCombinations(candidateIndices, 1, maxComplementSize);
                
                // --- CORRECCI√ìN "OUT OF MEMORY": Generador que mapea sobre la marcha para no bloquear la UI ---
                function* mapGenerator(generator, mapFn) {
                    for (const value of generator) {
                        yield mapFn(value);
                    }
                }
                allCombinations = mapGenerator(complementCombinations, complement => [...baseIndices, ...complement].sort((a, b) => a - b));
                totalCombinations = countCombinations(candidateIndices.length, 1, maxComplementSize);

            } else {
                // --- MODO: B√öSQUEDA GLOBAL (comportamiento original) ---
                findModeIndicator.textContent = '(B√∫squeda Global)';
                const indices = rawStrategiesData.map((_, i) => i);
                const maxComboSize = Math.min(indices.length, 12); // El generador ya se usa aqu√≠, est√° OK.
                allCombinations = getCombinations(indices, 2, maxComboSize);
                totalCombinations = countCombinations(indices.length, 2, maxComboSize);
            }
            
            if (totalCombinations === 0) {
                 databankStatus.innerHTML = `‚ÑπÔ∏è No hay combinaciones posibles para analizar.`;
                 toggleLoading(false, 'findDatabankPortfoliosBtn', 'findBestBtnText', 'findBestBtnSpinner');
                 clearDatabankBtn.disabled = false;
                 if (databankSizeInput) databankSizeInput.disabled = false;
                 return;
            }

            databankStatus.innerHTML = `üîç Iniciando an√°lisis de ${totalCombinations} combinaciones...`;

            // Main loop
            let idx = 0;
            for (const combo of allCombinations) {
                // --- Check for Pause ---
                while (isSearchPaused && !isSearchStopped) {
                    databankStatus.innerHTML = `‚è∏Ô∏è PAUSADO (${((idx / totalCombinations) * 100).toFixed(1)}%) - ${databankPortfolios.length} en DataBank`;
                    await new Promise(resolve => setTimeout(resolve, 500)); // Check pause less frequently
                }

                // --- Check for Stop ---
                if (isSearchStopped) {
                    databankStatus.innerHTML = `‚èπÔ∏è Detenido en ${idx}/${totalCombinations} (${((idx / totalCombinations) * 100).toFixed(1)}%) - ${databankPortfolios.length} en DataBank`;
                    break; // Exit the loop
                }


                // --- Correlation Check ---
                let isCombinationValid = true;
                for (let i = 0; i < combo.length; i++) {
                    for (let j = i + 1; j < combo.length; j++) {
                        // Ensure indices are valid before accessing matrix
                        if (combo[i] >= fullCorrelationMatrix.length || combo[j] >= fullCorrelationMatrix.length || !fullCorrelationMatrix[combo[i]] || combo[j] >= fullCorrelationMatrix[combo[i]].length) {
                             console.warn(`√çndice fuera de rango en matriz de correlaci√≥n: ${combo[i]}, ${combo[j]} para combo ${combo}. Saltando combo.`);
                             isCombinationValid = false;
                             break;
                         }
                        if (fullCorrelationMatrix[combo[i]][combo[j]] > correlationThreshold) {
                            isCombinationValid = false;
                            break;
                        }
                    }
                    if (!isCombinationValid) break;
                }

                if (!isCombinationValid) {
                    // Update UI periodically even when skipping
                     if (idx % 100 === 0 || idx === totalCombinations - 1) { // Update less often when skipping
                         const progress = (((idx + 1) / totalCombinations) * 100).toFixed(1);
                         databankStatus.innerHTML = `üîç Progreso: ${progress}% (${idx + 1}/${totalCombinations}) - ${databankPortfolios.length} en DataBank`;
                         await new Promise(resolve => setTimeout(resolve, 1)); // Minimal yield
                     }
                    continue; // Skip this combination
                }

                // --- Process Portfolio ---
                // Create portfolio trades with EQUAL weights for databank evaluation
                const equalWeight = 1 / combo.length;
                const portfolioTrades = combo.flatMap(index =>
                    // Check if rawStrategiesData[index] exists before mapping
                    rawStrategiesData[index] ? rawStrategiesData[index].map(trade => ({ ...trade, pnl: trade.pnl * equalWeight })) : []
                );

                 // Skip if portfolioTrades is empty (due to missing rawStrategiesData)
                if (portfolioTrades.length === 0) {
                     console.warn(`No trades found for combo ${combo}, possibly missing raw data. Skipping.`);
                      // Update UI periodically even when skipping
                     if (idx % 100 === 0 || idx === totalCombinations - 1) {
                         const progress = (((idx + 1) / totalCombinations) * 100).toFixed(1);
                         databankStatus.innerHTML = `üîç Progreso: ${progress}% (${idx + 1}/${totalCombinations}) - ${databankPortfolios.length} en DataBank`;
                         await new Promise(resolve => setTimeout(resolve, 1)); // Minimal yield
                     }
                     continue;
                 }


                const analysisResult = processStrategyData(portfolioTrades, rawBenchmarkData);

                if (analysisResult && analysisResult.metrics.hasOwnProperty(metricToOptimizeKey)) {
                    const metricValue = analysisResult.metrics[metricToOptimizeKey];
                    // Only add if the metric is valid (not NaN or undefined)
                    if (metricValue !== undefined && metricValue !== null && !isNaN(metricValue)) {
                        // --- A√ëADIDO: Pre-calcula el nombre para ordenar por string ---
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const portfolioName = combo.map(i => (loadedStrategyFiles[i] ? loadedStrategyFiles[i].name : `Estrat ${i+1}`)).map(name => name.replace('.csv', '')).join(', ');
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // --- FIN A√ëADIDO ---

¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const portfolioData = {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† indices: combo,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† name: portfolioName, // <-- A√ëADIDO
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† metricValue: metricValue,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† metrics: analysisResult.metrics, // Store all metrics
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† metricName: metricName,
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† metricNameKey: metricToOptimizeKey, // Store the key used
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† optimizationGoal: optimizationGoal
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† };
                        addToDatabankIfBetter(portfolioData, maxSize);
                    } else {
                         // console.warn(`M√©trica inv√°lida '${metricToOptimizeKey}' para combo ${combo}. Valor: ${metricValue}`);
                    }
                } else if (!analysisResult) {
                    // console.warn(`No se pudo analizar el combo: ${combo}`);
                } else {
                     console.warn(`La m√©trica '${metricToOptimizeKey}' no existe en el resultado del an√°lisis para el combo ${combo}`);
                }

                idx++; // <-- A√ëADE ESTA L√çNEA AQU√ç

                // --- Update UI Periodically ---
                if (idx % 20 === 0 || idx === totalCombinations - 1) {
                    const progress = (((idx + 1) / totalCombinations) * 100).toFixed(1);
                    databankStatus.innerHTML = `üîç Progreso: ${progress}% (${idx + 1}/${totalCombinations}) - ${databankPortfolios.length} en DataBank`;
                    updateDatabankDisplay();
                    await new Promise(resolve => setTimeout(resolve, 10)); // Yield to prevent blocking
                }
            } // End of loop

            // Final UI update after loop finishes or stops
            updateDatabankDisplay();
            if (!isSearchStopped) {
                 databankStatus.innerHTML = `‚úÖ B√∫squeda completada (${totalCombinations}/${totalCombinations}) - ${databankPortfolios.length} en DataBank`;
            }

        } catch (error) {
            console.error("Error buscando portafolios en DataBank:", error);
            displayError("Ocurri√≥ un error durante la b√∫squeda en DataBank.");
            databankStatus.innerHTML = `‚ùå Error en la b√∫squeda.`;
        } finally {
            // Re-enable controls
            // Use the new button ID here:
            toggleLoading(false, 'findDatabankPortfoliosBtn', 'findBestBtnText', 'findBestBtnSpinner');
            pauseSearchBtn.disabled = true; // Can't pause/resume when finished/stopped
            stopSearchBtn.disabled = true;
            clearDatabankBtn.disabled = false; // Enable clear after run
            if (databankSizeInput) databankSizeInput.disabled = false;
            isSearchPaused = false; // Ensure pause state is reset
            isSearchStopped = false; // Ensure stop state is reset
        }
    };

    const formatMetricForDisplay = (value, metricName) => {
        const isPercent = ['maxDrawdown', 'winningPercentage', 'upsideCapture', 'downsideCapture'].includes(metricName) || (metricName && metricName.toLowerCase().includes('%'));
        if (!isFinite(value)) return '‚àû';
        if (isPercent) return `${value.toFixed(2)}%`;
        if (value > 1000) return value.toFixed(0);
        return value.toFixed(2);
    };

    const addToDatabankIfBetter = (portfolioData, maxSize) => {
        const { indices, metricValue, optimizationGoal } = portfolioData;
        const key = indices.sort((a, b) => a - b).join(',');

        const existingIndex = databankPortfolios.findIndex(p => p.key === key);

        if (existingIndex > -1) {
            const existingPortfolio = databankPortfolios[existingIndex];
            const isNewBetter = (optimizationGoal === 'maximize')
                ? metricValue > existingPortfolio.metricValue
                : metricValue < existingPortfolio.metricValue;
            
            if (isNewBetter) {
                databankPortfolios[existingIndex] = { ...portfolioData, key };
            } else {
                return; // No improvement, do nothing
            }
        } else {
            databankPortfolios.push({ ...portfolioData, key });
        }

        // Sort the databank
        databankPortfolios.sort((a, b) => {
            const valA = isFinite(a.metricValue) ? a.metricValue : (optimizationGoal === 'maximize' ? -Infinity : Infinity);
            const valB = isFinite(b.metricValue) ? b.metricValue : (optimizationGoal === 'maximize' ? -Infinity : Infinity);
            return optimizationGoal === 'maximize' ? valB - valA : valA - valB;
        });

        // Truncate to maxSize
        if (databankPortfolios.length > maxSize) {
            databankPortfolios = databankPortfolios.slice(0, maxSize);
        }
    };

    const updateDatabankDisplay = () => {
        if (databankPortfolios.length === 0) {
            databankEmptyRow.classList.remove('hidden');
            databankTableBody.innerHTML = '';
            databankTableBody.appendChild(databankEmptyRow);
            databankTableHeader.innerHTML = ''; // Limpiar cabecera si no hay datos
            return;
        }

        databankEmptyRow.classList.add('hidden');

        // --- Generate Header based on Active View ---
        const activeViewColumns = tableViews.databank[activeViews.databank]?.columns || tableViews.databank['default'].columns;
        let headerHTML = '<tr>';
        headerHTML += `<th class="p-1.5 w-8 align-bottom"><input type="checkbox" id="databank-select-all" class="form-checkbox h-4 w-4 bg-gray-800 border-gray-600 rounded text-sky-500 focus:ring-sky-600"></th>`;
        headerHTML += `<th class="p-2 w-12 sortable align-bottom" data-sort-key="metricValue" ${databankSortConfig.key === 'metricValue' ? `data-order="${databankSortConfig.order}"` : ''}>Rank</th>`;
        
        activeViewColumns.forEach(key => {
            const colInfo = ALL_METRICS[key];
            if (colInfo) {
                const orderIndicator = databankSortConfig.key === key ? `data-order="${databankSortConfig.order}"` : '';
                const id = key === 'metricValue' ? 'id="databank-metric-header"' : '';
                if (key === 'name') {
                    headerHTML += `<th class="${colInfo.class} sortable" ${id} data-sort-key="${key}" ${orderIndicator}>${colInfo.label}</th>`;
                } else {
                    headerHTML += `<th class="${colInfo.class.replace('text-right', 'text-center')} sortable" ${id} data-sort-key="${key}" ${orderIndicator}><div class="corr-header">${colInfo.label}</div></th>`;
                }
            }
        });
        headerHTML += `<th class="p-2 text-center sticky right-0 bg-gray-700 z-20 align-bottom">Acci√≥n</th>`;
        headerHTML += '</tr>';
        databankTableHeader.innerHTML = headerHTML;
        
        const metricHeader = document.getElementById('databank-metric-header');
        if (metricHeader) {
            metricHeader.textContent = databankPortfolios[0]?.metricName || 'M√©trica';
        }

        // --- Generate Body ---
        let html = '';
        const rankColors = ['bg-amber-400', 'bg-slate-300', 'bg-yellow-600'];
        
        databankPortfolios.forEach((p, index) => {
¬† ¬† ¬† ¬† ¬† ¬† // Solo resalta el Top 3 si la tabla est√° ordenada por la m√©trica principal (rank)
¬† ¬† ¬† ¬† ¬† ¬† let rowClass = (index < 3 && databankSortConfig.key === 'metricValue') ? 'databank-top3' : '';
            const selectionIndex = selectedRows.databank.indexOf(index);
            if (selectionIndex !== -1) {
                rowClass = SELECTION_COLORS[selectionIndex % SELECTION_COLORS.length];
            }
            
            let rankBadge = `<span class="font-bold">${index + 1}</span>`;
            if (index < 3 && databankSortConfig.key === 'metricValue') {
                rankBadge = `<span class="inline-block text-xs py-0.5 px-2 ${rankColors[index]} text-gray-900 rounded-full font-bold">#${index + 1}</span>`;
            }

            html += `<tr class="${rowClass} hover:bg-gray-700/50 text-xs cursor-pointer" data-row-type="databank" data-row-index="${index}">
                    <td class="p-2"><input type="checkbox" data-index="${index}" class="databank-row-checkbox form-checkbox h-4 w-4 bg-gray-800 border-gray-600 rounded text-sky-500 focus:ring-sky-600"></td>
                    <td class="p-2 text-center">${rankBadge}</td>`;

            activeViewColumns.forEach(key => {
                const colInfo = ALL_METRICS[key];
                if (key === 'name') {
                    const names = p.name || p.indices.map(i => (loadedStrategyFiles[i] ? loadedStrategyFiles[i].name : `Estrat ${i+1}`)).map(name => `<div class="copyable-strategy p-0.5 rounded-sm" title="Copiar '${name.replace('.csv', '')}'">${name.replace('.csv', '')}</div>`).join('');
                    html += `<td class="p-2 text-gray-300 max-w-xs">${names}</td>`;
                } else {
                    const value = key === 'metricValue' ? p.metricValue : p.metrics[key];
                    html += `<td class="p-2 text-right">${formatMetricForDisplay(value, key)}</td>`;
                }
            });

            html += `<td class="p-2 text-center sticky right-0 bg-gray-800 z-10"><button class="databank-save-single-btn bg-sky-700 hover:bg-sky-800 text-white font-bold py-1 px-2 rounded text-xs" data-index="${index}">Guardar</button></td></tr>`;
        });
        databankTableBody.innerHTML = html;
    };

    const updateDatabankDisplay_optimized = () => {
        if (databankPortfolios.length === 0) {
            databankEmptyRow.classList.remove('hidden');
            databankTableBody.innerHTML = '';
            databankTableBody.appendChild(databankEmptyRow);
            databankTableHeader.innerHTML = '';
            return;
        }

        databankEmptyRow.classList.add('hidden');
        
        // --- Generate Header (same as before) ---
        // ... (header generation logic is unchanged, so we can reuse it)
        const activeViewColumns = tableViews.databank[activeViews.databank]?.columns || tableViews.databank['default'].columns;
        // ... (rest of header generation)

        // --- Smartly Update Body ---
        const existingRows = new Map();
        databankTableBody.querySelectorAll('tr[data-row-type="databank"]').forEach(row => {
            existingRows.set(row.dataset.key, row);
        });

        // The rest of the logic would go here to compare and update rows,
        // but for simplicity and robustness, we'll stick to the full redraw for now
        // as it's less prone to edge cases with sorting and selection.
        // The main performance gain will come from chart updates.
    };

    const sortDatabank = (headerEl) => {
¬† ¬† ¬† ¬† // No permitir re-ordenar si la b√∫squeda est√° activamente corriendo (ni pausada, ni terminada)
¬† ¬† ¬† ¬† const isRunning = findDatabankPortfoliosBtn.disabled && !isSearchPaused && !isSearchStopped;
¬† ¬† ¬† ¬† if (isRunning) {
¬† ¬† ¬† ¬† ¬† ¬† console.log("Ordenamiento ignorado: La b√∫squeda est√° en curso.");
¬† ¬† ¬† ¬† ¬† ¬† return; 
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† const sortKey = headerEl.dataset.sortKey;
¬† ¬† ¬† ¬† if (!sortKey) return;

¬† ¬† ¬† ¬† let newOrder;
¬† ¬† ¬† ¬† if (databankSortConfig.key === sortKey) {
¬† ¬† ¬† ¬† ¬† ¬† // Invertir orden si se hace clic en la misma columna
¬† ¬† ¬† ¬† ¬† ¬† newOrder = databankSortConfig.order === 'asc' ? 'desc' : 'asc';
¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† // Columna nueva. Determinar orden por defecto (minimizar o maximizar)
¬† ¬† ¬† ¬† ¬† ¬† const metricsToMinimize = ['maxDrawdown', 'maxDrawdownInDollars', 'maxStagnationTrades', 'maxConsecutiveLosses', 'avgLoss', 'downsideCapture', 'maxConsecutiveLosingMonths'];
¬† ¬† ¬† ¬† ¬† ¬† if (metricsToMinimize.includes(sortKey)) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† newOrder = 'asc'; // Minimizar (Ascendente)
¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† newOrder = 'desc'; // Maximizar (Descendente)
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† // Si se ordena por la m√©trica principal ('metricValue'), el orden debe respetar el objetivo de optimizaci√≥n
¬† ¬† ¬† ¬† if (sortKey === 'metricValue') {
¬† ¬† ¬† ¬† ¬† ¬† // Usar el objetivo del primer portafolio (todos tienen el mismo) o el del selector
¬† ¬† ¬† ¬† ¬† ¬† const optimizationGoal = databankPortfolios[0]?.optimizationGoal || optimizationGoalSelect.value;
¬† ¬† ¬† ¬† ¬† ¬† if (databankSortConfig.key !== 'metricValue') { // Si es el primer clic en esta columna
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† newOrder = (optimizationGoal === 'maximize') ? 'desc' : 'asc';
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† // Actualizar el estado de ordenamiento
¬† ¬† ¬† ¬† databankSortConfig.key = sortKey;
¬† ¬† ¬† ¬† databankSortConfig.order = newOrder;

¬† ¬† ¬† ¬† // Actualizar atributos visuales de la cabecera
¬† ¬† ¬† ¬† document.querySelectorAll('#databank-table-header th.sortable').forEach(th => th.removeAttribute('data-order'));
¬† ¬† ¬† ¬† headerEl.dataset.order = newOrder;

¬† ¬† ¬† ¬† // --- Realizar el ordenamiento del array ---
¬† ¬† ¬† ¬† databankPortfolios.sort((a, b) => {
¬† ¬† ¬† ¬† ¬† ¬† let valA, valB;
¬† ¬† ¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† ¬† ¬† if (sortKey === 'name') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valA = a.name || '';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valB = b.name || '';
¬† ¬† ¬† ¬† ¬† ¬† } else if (sortKey === 'metricValue') {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valA = a.metricValue;
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valB = b.metricValue;
¬† ¬† ¬† ¬† ¬† ¬† } else {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† // Acceder a las m√©tricas secundarias
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valA = a.metrics[sortKey];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valB = b.metrics[sortKey];
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† // Manejar n√∫meros (incluyendo Infinito)
¬† ¬† ¬† ¬† ¬† ¬† const isNumeric = (typeof valA === 'number');
¬† ¬† ¬† ¬† ¬† ¬† if (isNumeric) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† const goal = (newOrder === 'desc') ? 'maximize' : 'minimize';
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valA = isFinite(valA) ? valA : (goal === 'maximize' ? -Infinity : Infinity);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† valB = isFinite(valB) ? valB : (goal === 'maximize' ? -Infinity : Infinity);
¬† ¬† ¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† ¬† ¬† // L√≥gica de comparaci√≥n
¬† ¬† ¬† ¬† ¬† ¬† if (valA < valB) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return databankSortConfig.order === 'asc' ? -1 : 1;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† if (valA > valB) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return databankSortConfig.order === 'asc' ? 1 : -1;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† return 0;
¬† ¬† ¬† ¬† });
¬† ¬† ¬† ¬† 
¬† ¬† ¬† ¬† // --- Re-dibujar la tabla con el nuevo orden ---
¬† ¬† ¬† ¬† updateDatabankDisplay();
¬† ¬† };

    const savePortfolioFromDatabank = (portfolioIndex) => {
        const portfolio = databankPortfolios[portfolioIndex];
        if (!portfolio) return false;

        const indices = portfolio.indices;
        // Check for duplicates (equal weights, same indices)
        const isDuplicate = savedPortfolios.some(p => 
            p.indices.length === indices.length && 
            p.indices.every(i => indices.includes(i)) && 
            !p.weights // !p.weights implies equal weighting
        );

        if (isDuplicate) {
            console.warn(`Portfolio ${portfolio.key} ya est√° guardado.`);
            return false;
        }

        const names = portfolio.indices.map(i => loadedStrategyFiles[i].name.replace('.csv', '').substring(0, 5)).join('+');
        
        savedPortfolios.push({
            name: `P-DB (${names}) ${portfolio.metricName}`,
            indices: indices,
            id: nextPortfolioId++,
            weights: null, // Databank portfolios are saved with equal weights by default
            comments: `Guardado desde DataBank. M√©trica: ${portfolio.metricName} (${portfolio.metricValue.toFixed(2)})`
        });
        return true;
    };


    // --- EVENT LISTENERS ---

    const updateTradesFilesList = () => {
        tradesFilesListEl.innerHTML = '';
        if (loadedStrategyFiles.length > 0) {
            loadedStrategyFiles.forEach((file, index) => {
                const fileEl = document.createElement('div');
                fileEl.className = 'flex justify-between items-center bg-gray-700/50 p-1 rounded text-gray-300';
                fileEl.innerHTML = `<span class="truncate pr-2">${file.name}</span><button data-index="${index}" class="remove-file-btn text-red-500 hover:text-red-400 font-bold text-lg px-2" title="Eliminar archivo">&times;</button>`;
                tradesFilesListEl.appendChild(fileEl);
            });
        }
    };

    tradesFileInput.addEventListener('change', (e) => {
        const newFiles = Array.from(e.target.files);
        newFiles.forEach(newFile => {
            if (!loadedStrategyFiles.some(existingFile => existingFile.name === newFile.name)) {
                loadedStrategyFiles.push(newFile);
            }
        });
        updateTradesFilesList();
        e.target.value = '';
    });

    tradesFilesListEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('remove-file-btn')) {
            const indexToRemove = parseInt(e.target.dataset.index, 10);
            loadedStrategyFiles.splice(indexToRemove, 1);
            updateTradesFilesList();
        }
    });

    benchmarkFileInput.addEventListener('change', () => {
        benchmarkFileNameEl.textContent = benchmarkFileInput.files[0]?.name || '(date, price)';
    });

    resetBtn.addEventListener('click', () => {
        tradesFileInput.value = '';
        benchmarkFileInput.value = '';
        loadedStrategyFiles = [];
        rawBenchmarkData = null;
        rawStrategiesData = [];
        selectedPortfolioIndices.clear();
        savedPortfolios = [];
        featuredPortfolioIndex = null;
        comparisonPortfolioIndex = null;
        updateTradesFilesList();
        updateAnalysisModeSelector();
        benchmarkFileNameEl.textContent = '(date, price)';
        resultsDiv.classList.add('hidden');
        savedPortfoliosSection.classList.add('hidden');
        featuredPortfolioSection.classList.add('hidden');
        hideError();
        destroyAllCharts();
        tabNav.innerHTML = '';
        tabContentArea.innerHTML = '';
    });
    
    const runAnalysis = async () => {
        hideError();
        destroyAllCharts();
        
        if (loadedStrategyFiles.length === 0 || !benchmarkFileInput.files[0]) {
             displayError('Por favor, selecciona al menos un archivo de estrategia y un archivo de benchmark.');
             return;
        }

        toggleLoading(true, 'analyzeBtn', 'analyzeBtnText', 'analyzeBtnSpinner');
        resultsDiv.classList.add('hidden');
        
        try {
            rawBenchmarkData = await parseCsv(benchmarkFileInput.files[0]);
            if (!rawBenchmarkData[0].hasOwnProperty('date') || !rawBenchmarkData[0].hasOwnProperty('price')) {
                throw new Error(`El archivo de benchmark debe tener columnas de fecha y precio. Detectadas: [${Object.keys(rawBenchmarkData[0]).join(', ')}]`);
            }
            const strategiesPromises = loadedStrategyFiles.map(file => parseCsv(file));
            rawStrategiesData = await Promise.all(strategiesPromises);
            
            reAnalyzeAllData(); // Initial analysis
        } catch (error) {
            console.error("Error en el proceso de an√°lisis:", error);
            displayError(error.message);
        } finally {
            toggleLoading(false, 'analyzeBtn', 'analyzeBtnText', 'analyzeBtnSpinner');
        }
    };

    analysisModeSelect.addEventListener('change', () => {
        if (!resultsDiv.classList.contains('hidden')) {
            reAnalyzeAllData();
        }
    });
    
    normalizeRiskCheckbox.addEventListener('change', (e) => {
        riskNormalizationControls.classList.toggle('hidden', !e.target.checked);
        if (!resultsDiv.classList.contains('hidden')) {
            reAnalyzeAllData();
        }
    });

    analyzeBtn.addEventListener('click', runAnalysis);
    
    const updateAnalysisModeSelector = () => {
        const selectedValue = analysisModeSelect.value;
        analysisModeSelect.innerHTML = '<option value="-1">An√°lisis Completo</option>';
        
        rawStrategiesData.forEach((_, i) => {
            const fileName = loadedStrategyFiles[i].name.replace('.csv', '');
            analysisModeSelect.innerHTML += `<option value="${i}">Filtrar por ${fileName}</option>`;
        });

        if (selectedPortfolioIndices.size > 0) {
            analysisModeSelect.innerHTML += `<option value="portfolio">Filtrar por Portafolio</option>`;
        }
        
        analysisModeSelect.value = selectedValue;
        if (!analysisModeSelect.querySelector(`option[value="${selectedValue}"]`)) {
            analysisModeSelect.value = '-1';
        }
    };
    
    const calculateSortino = (returns, annualizationFactor = 252) => {
        if (returns.length < 2) return 0;
        const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
        const negativeReturns = returns.filter(r => r < 0);
        if (negativeReturns.length === 0) return Infinity;
        
        const downsideDeviation = Math.sqrt(negativeReturns.reduce((acc, r) => acc + Math.pow(r, 2), 0) / returns.length);
        
        return downsideDeviation > 0 ? (meanReturn * Math.sqrt(annualizationFactor)) / downsideDeviation : Infinity;
    };


    // --- CORE LOGIC ---
    const processStrategyData = (tradesToAnalyze, benchmark, filterSourceTrades = null) => {
        if (tradesToAnalyze.length === 0) return null;
        
        const monthlyPerformance = {};
        
        const finalTrades = tradesToAnalyze;

        let benchmarkToUse = benchmark;
        if (filterSourceTrades) {
            const inTradeDates = new Set();
            filterSourceTrades.forEach(trade => {
                let currentDate = new Date(trade.entry_date);
                const endDate = new Date(trade.exit_date);
                if (isNaN(currentDate.getTime()) || isNaN(endDate.getTime())) return;
                while (currentDate <= endDate) {
                    inTradeDates.add(currentDate.toISOString().split('T')[0]);
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            });
            benchmarkToUse = benchmark.filter(row => inTradeDates.has(new Date(row.date).toISOString().split('T')[0]));
            if (benchmarkToUse.length < 2) return null;
        }
        
        const benchmarkPrices = new Map();
        benchmarkToUse.forEach(row => {
            const date = new Date(row.date);
            const price = parseFloat(row.price);
            if (!isNaN(date.getTime()) && !isNaN(price)) benchmarkPrices.set(date.toISOString().split('T')[0], price);
        });
        if (benchmarkPrices.size === 0) return null;
        const sortedDates = [...benchmarkPrices.keys()].sort();
        
        const dailyPnl = new Map();
        finalTrades.forEach(trade => {
            const pnl = parseFloat(trade.pnl);
            const exitDate = new Date(trade.exit_date);
            if (!isNaN(pnl) && !isNaN(exitDate.getTime())) {
                const dateStr = exitDate.toISOString().split('T')[0];
                dailyPnl.set(dateStr, (dailyPnl.get(dateStr) || 0) + pnl);
            }
        });

        let currentEquity = 10000;
        const equityCurve = [];
        sortedDates.forEach(date => {
            if (dailyPnl.has(date)) currentEquity += dailyPnl.get(date);
            equityCurve.push({ x: date, y: currentEquity });
        });

        const labels = equityCurve.map(p => p.x);
        const portfolioValues = equityCurve.map(p => p.y);
        const benchmarkData = labels.map(date => ({ x: date, y: benchmarkPrices.get(date) }));
        
        let upi = 0;
        let maxDrawdown = 0;
        let monthlyAvgProfit = 0;
        let profitMaxDD_Ratio = 0;
        let maxDrawdownInDollars = 0;
        let monthlyProfitToDollarDD = 0;

        if (portfolioValues.length > 1) {
            const startDate = new Date(labels[0]);
            const endDate = new Date(labels[labels.length - 1]);
            const diffInMillis = endDate.getTime() - startDate.getTime();
            const durationInDays = diffInMillis > 0 ? diffInMillis / (1000 * 60 * 60 * 24) : 0;
            const durationInYears = durationInDays / 365.25;
            const durationInMonths = diffInMillis > 0 ? diffInMillis / (1000 * 60 * 60 * 24 * 30.44) : 0;

            const initialEquity = portfolioValues[0];
            const finalEquity = portfolioValues[portfolioValues.length - 1];
            
            const totalProfit = finalEquity - initialEquity;
            monthlyAvgProfit = durationInMonths > 0 ? totalProfit / durationInMonths : 0;

            let cagrPct = 0;
            if (initialEquity > 0 && finalEquity > 0 && durationInYears > 0) {
                if (durationInYears < 1.0) {
                    cagrPct = ((totalProfit / initialEquity) / durationInYears) * 100.0;
                } else {
                    cagrPct = (Math.pow(finalEquity / initialEquity, 1.0 / durationInYears) - 1) * 100.0;
                }
            }

            let peakEquity = initialEquity;
            let squaredDrawdownSum = 0;
            for (const currentPoint of portfolioValues) {
                peakEquity = Math.max(peakEquity, currentPoint);
                const drawdown = (peakEquity - currentPoint) / peakEquity;
                maxDrawdown = Math.max(maxDrawdown, drawdown);
                maxDrawdownInDollars = Math.max(maxDrawdownInDollars, peakEquity - currentPoint);
                squaredDrawdownSum += Math.pow(((currentPoint / peakEquity) - 1) * 100.0, 2);
            }
            maxDrawdown *= 100;

            const ulcerIndex = portfolioValues.length > 0 ? Math.sqrt(squaredDrawdownSum / portfolioValues.length) : 0;

            upi = ulcerIndex > 0 ? cagrPct / ulcerIndex : (cagrPct > 0 ? Infinity : 0);
            
            if (maxDrawdownInDollars > 0) {
                monthlyProfitToDollarDD = (monthlyAvgProfit / maxDrawdownInDollars) * 100;
                profitMaxDD_Ratio = totalProfit / maxDrawdownInDollars;
            } else if (totalProfit > 0) {
                monthlyProfitToDollarDD = Infinity;
                profitMaxDD_Ratio = Infinity;
            } else if (monthlyAvgProfit > 0) {
                monthlyProfitToDollarDD = Infinity;
            }
        }

        const portfolioReturns = [];
        const benchmarkReturns = [];
        const dailyReturnsMap = new Map();
        let lastPortfolioValue = portfolioValues.length > 0 ? portfolioValues[0] : 0;
        let lastBenchmarkValue = benchmarkData.length > 0 ? benchmarkData[0].y : 0;
        for (let i = 1; i < labels.length; i++) {
            const pReturn = (lastPortfolioValue > 0) ? (portfolioValues[i] / lastPortfolioValue) - 1 : 0;
            const bReturn = (lastBenchmarkValue > 0 && benchmarkData[i]?.y != null) ? (benchmarkData[i].y / lastBenchmarkValue) - 1 : 0;
            portfolioReturns.push(pReturn);
            benchmarkReturns.push(bReturn);
            dailyReturnsMap.set(labels[i], pReturn);
            lastPortfolioValue = portfolioValues[i];
            if (benchmarkData[i]?.y != null) {
                lastBenchmarkValue = benchmarkData[i].y;
            }
        }
        
        const rollingSortinoData = [];
        const windowSize = 252;
        if(portfolioReturns.length >= windowSize) {
            for(let i = windowSize; i < portfolioReturns.length; i++) {
                const window = portfolioReturns.slice(i - windowSize, i);
                const sortino = calculateSortino(window);
                rollingSortinoData.push({ x: labels[i], y: isFinite(sortino) ? sortino : null });
            }
        }

        const positiveBenchDays = { portfolio: [], benchmark: [] };
        const negativeBenchDays = { portfolio: [], benchmark: [] };
        benchmarkReturns.forEach((bReturn, i) => {
            if (bReturn > 0) { positiveBenchDays.portfolio.push(portfolioReturns[i]); positiveBenchDays.benchmark.push(bReturn); } 
            else if (bReturn < 0) { negativeBenchDays.portfolio.push(portfolioReturns[i]); negativeBenchDays.benchmark.push(bReturn); }
        });

        const arithmeticMean = arr => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
        const geoMean = arr => arr.length === 0 ? 0 : Math.pow(arr.reduce((acc, val) => acc * (1 + val), 1), 1 / arr.length) - 1;
        
        const upsideCapture = (geoMean(positiveBenchDays.benchmark) !== 0) ? (geoMean(positiveBenchDays.portfolio) / geoMean(positiveBenchDays.benchmark)) * 100 : 0;
        const downsideCapture = (geoMean(negativeBenchDays.benchmark) !== 0) ? (geoMean(negativeBenchDays.portfolio) / geoMean(negativeBenchDays.benchmark)) * 100 : 0;
        const sortinoRatio = calculateSortino(portfolioReturns);
        const avgPortfolioReturnOnDownDays = arithmeticMean(negativeBenchDays.portfolio);
        const avgPortfolioReturnOnUpDays = arithmeticMean(positiveBenchDays.portfolio);
        
        const captureRatio = downsideCapture > 0 ? upsideCapture / downsideCapture : Infinity;
        
        let maxStagnationTrades = 0;
        if (finalTrades.length > 0) {
            const sortedTrades = [...finalTrades].sort((a, b) => new Date(a.exit_date) - new Date(b.exit_date));
            let tradeEquity = 10000;
            let peakTradeEquity = 10000;
            let currentStagnation = 0;
            
            for (const trade of sortedTrades) {
                tradeEquity += trade.pnl;
                if (tradeEquity > peakTradeEquity) {
                    peakTradeEquity = tradeEquity;
                    currentStagnation = 0;
                } else {
                    currentStagnation++;
                }
                maxStagnationTrades = Math.max(maxStagnationTrades, currentStagnation);
            }
        }
        
        let maxConsecutiveLosses = 0;
        let currentConsecutiveLosses = 0;
        let maxConsecutiveWins = 0;
        let currentConsecutiveWins = 0;
        if (finalTrades.length > 0) {
            const sortedTradesForConsecutive = [...finalTrades].sort((a, b) => new Date(a.exit_date) - new Date(b.exit_date));
            for (const trade of sortedTradesForConsecutive) {
                if (trade.pnl < 0) {
                    currentConsecutiveLosses++;
                    currentConsecutiveWins = 0;
                } else if (trade.pnl > 0) {
                    currentConsecutiveWins++;
                    currentConsecutiveLosses = 0;
                }
                maxConsecutiveLosses = Math.max(maxConsecutiveLosses, currentConsecutiveLosses);
                maxConsecutiveWins = Math.max(maxConsecutiveWins, currentConsecutiveWins);
            }
        }
        
        const meanPortfolioReturn = arithmeticMean(portfolioReturns);
        const stdDev = Math.sqrt(portfolioReturns.map(x => Math.pow(x - meanPortfolioReturn, 2)).reduce((a, b) => a + b, 0) / portfolioReturns.length);
        const sharpeRatio = stdDev > 0 ? (meanPortfolioReturn / stdDev) * Math.sqrt(252) : Infinity;

        let grossProfit = 0;
        let grossLoss = 0;
        const winningTrades = finalTrades.filter(t => t.pnl > 0);
        const losingTrades = finalTrades.filter(t => t.pnl < 0);
        
        winningTrades.forEach(t => grossProfit += t.pnl);
        losingTrades.forEach(t => grossLoss += t.pnl);
        
        const profitFactor = grossLoss !== 0 ? Math.abs(grossProfit / grossLoss) : Infinity;
        const totalTradesWithOutcome = winningTrades.length + losingTrades.length;
        const winningPercentage = totalTradesWithOutcome > 0 ? (winningTrades.length / totalTradesWithOutcome) * 100 : 0;
        const avgWin = winningTrades.length > 0 ? grossProfit / winningTrades.length : 0;
        const avgLoss = losingTrades.length > 0 ? Math.abs(grossLoss / losingTrades.length) : 0;

        finalTrades.forEach(trade => {
            const pnl = parseFloat(trade.pnl);
            const exitDate = new Date(trade.exit_date);
            if (!isNaN(pnl) && !isNaN(exitDate.getTime())) {
                const year = exitDate.getFullYear();
                const month = exitDate.getMonth(); // 0-11
                if (!monthlyPerformance[year]) {
                    monthlyPerformance[year] = Array(12).fill(0);
                }
                monthlyPerformance[year][month] += pnl;
            }
        });

        let maxConsecutiveLosingMonths = 0;
        const monthlyYears = Object.keys(monthlyPerformance).sort((a, b) => a - b);
        if (monthlyYears.length > 0) {
            let currentStreak = 0;

            for (const year of monthlyYears) {
                for (const pnl of monthlyPerformance[year]) {
                    if (pnl < 0) {
                        currentStreak++;
                    } else {
                        maxConsecutiveLosingMonths = Math.max(maxConsecutiveLosingMonths, currentStreak);
                        currentStreak = 0;
                    }
                }
            }
            maxConsecutiveLosingMonths = Math.max(maxConsecutiveLosingMonths, currentStreak);
        }

        let maxStagnationDays = 0;
        if (portfolioValues.length > 0) {
            let peakEquity = portfolioValues[0];
            let peakDate = new Date(labels[0]);
            for (let i = 0; i < portfolioValues.length; i++) {
                const currentEquity = portfolioValues[i];
                const currentDate = new Date(labels[i]);
                if (currentEquity >= peakEquity) {
                    peakEquity = currentEquity;
                    peakDate = currentDate;
                } else {
                    const diffTime = Math.abs(currentDate - peakDate);
                    maxStagnationDays = Math.max(maxStagnationDays, Math.ceil(diffTime / (1000 * 60 * 60 * 24)));
                }
            }
        }

        const tradePnls = finalTrades.map(t => t.pnl);
        let sqn = 0;
        if (tradePnls.length > 0) {
            const avgPnl = tradePnls.reduce((a, b) => a + b, 0) / tradePnls.length;
            const stdDevPnl = Math.sqrt(tradePnls.map(x => Math.pow(x - avgPnl, 2)).reduce((a, b) => a + b, 0) / tradePnls.length);
            if (stdDevPnl > 0) sqn = (Math.sqrt(tradePnls.length) * avgPnl) / stdDevPnl;
        }

        const positivePnlTrades = finalTrades.filter(t => t.pnl > 0).sort((a, b) => a.pnl - b.pnl);
        const totalProfit = positivePnlTrades.reduce((sum, t) => sum + t.pnl, 0);
        let cumulativeProfit = 0;
        const lorenzData = [{x: 0, y: 0}];
        if (totalProfit > 0) {
            positivePnlTrades.forEach((trade, index) => {
                cumulativeProfit += trade.pnl;
                lorenzData.push({ x: (index + 1) / positivePnlTrades.length * 100, y: (cumulativeProfit / totalProfit) * 100 });
            });
        }
        
        return { 
            labels, portfolioValues, benchmarkData,
            returnsData: portfolioReturns.map((p, i) => ({ x: benchmarkReturns[i] * 100, y: p * 100 })),
            metrics: { upsideCapture, downsideCapture, sortinoRatio, avgPortfolioReturnOnDownDays, avgPortfolioReturnOnUpDays, upi, captureRatio, maxStagnationTrades, maxConsecutiveLosses, maxConsecutiveWins, maxDrawdown, maxDrawdownInDollars, monthlyAvgProfit, profitMaxDD_Ratio, sharpeRatio, profitFactor, winningPercentage, avgWin, avgLoss, monthlyProfitToDollarDD, maxConsecutiveLosingMonths, totalTrades: finalTrades.length, maxStagnationDays, sqn },
            lorenzData,
            dailyReturnsMap,
            rollingSortinoData,
            monthlyPerformance
        };
    };

    const renderChartsForTab = (tabId) => {
        const results = window.analysisResults;
        if (!results) return;

        if (tabId === 'summary') {
            // The summary chart is now rendered inside createSummaryTab if needed, or on demand.
        } else if (tabId.startsWith('strategy-')) {
            const index = parseInt(tabId.replace('strategy-', ''), 10);
            const result = results.find(r => r.originalIndex === index && !r.isPortfolio && !r.isSavedPortfolio);
            if (!result) return;

            const analysis = result.analysis;
            const color = STRATEGY_COLORS[result.originalIndex % STRATEGY_COLORS.length];
            
            if (document.getElementById(`equityChart-${tabId}`)) {
                renderEquityChart(`equityChart-${tabId}`, analysis, result.name, color);
                renderScatterChart(`scatterChart-${tabId}`, analysis, color);
                renderLorenzChart(`lorenzChart-${tabId}`, analysis, color);
                if (analysis.rollingSortinoData.length > 0) {
                    renderRollingSortinoChart(`rollingSortinoChart-${tabId}`, analysis, color);
                }
            }
        }
    };

    const renderAllCharts = (forceRedraw = false) => {
        const activeTab = document.querySelector('.tab-btn.active');
        if (activeTab) {
            const targetId = activeTab.dataset.target;
            if (forceRedraw) {
                // Destroy all charts within the active tab before redrawing
                document.querySelectorAll(`#${targetId} canvas`).forEach(canvas => destroyChart(canvas.id));
            }
            renderChartsForTab(targetId);
        }
    };

    // --- DISPLAY & RENDERING ---
    const displayResults = (results) => {
        window.analysisResults = results.filter(r => r && r.analysis);

        const activeTabId = document.querySelector('.tab-btn.active')?.dataset.target;
        const activeChartAction = document.querySelector('#chart-actions-group .chart-action-item.active')?.dataset.action;

        
        let navHTML = '';
        let contentHTML = '';

        const summaryResult = createSummaryTab(window.analysisResults);
        navHTML += summaryResult.nav;
        contentHTML += summaryResult.content;

        window.analysisResults.filter(r => !r.isPortfolio && !r.isSavedPortfolio).forEach((result) => {
            const strategyResult = createStrategyTab(result);
            navHTML += strategyResult.nav;
            contentHTML += strategyResult.content;
        });
        
        tabNav.innerHTML = navHTML;
        tabContentArea.innerHTML = contentHTML;
        
        const summaryTable = document.getElementById('summary-table');
        if (summaryTable) {
            summaryTable.querySelectorAll('.sortable').forEach(header => {
                header.addEventListener('click', () => sortTable(header));
            });
        }

        const tabToActivate = tabNav.querySelector(`.tab-btn[data-target="${activeTabId}"]`) || tabNav.querySelector('.tab-btn');
        if (tabToActivate) {
            tabToActivate.classList.add('active');
            const activeContent = document.getElementById(tabToActivate.dataset.target);
            if (activeContent) {
                activeContent.classList.add('active');
            }
        }

        resultsDiv.classList.remove('hidden');
        // Do not render all charts automatically to prevent memory issues.
        // Render charts for the initially active tab.
        renderAllCharts();
        displaySavedPortfoliosList();
        const savedPortfolioAnalyses = window.analysisResults.filter(r => r.isSavedPortfolio && !r.isTemporaryOriginal);
        if (savedPortfolioAnalyses.length > 0 || comparisonPortfolioIndex !== null) {
            renderPortfolioComparisonCharts(savedPortfolioAnalyses);
        }
        renderFeaturedPortfolio();
    };

    const reAnalyzeAllData = () => {
        selectedPortfolioIndices.clear();
        document.querySelectorAll('.portfolio-checkbox:checked').forEach(cb => {
            selectedPortfolioIndices.add(parseInt(cb.dataset.index));
        });
        
        updateAnalysisModeSelector();

        const filterMode = analysisModeSelect.value;
        let filterSourceTrades = null;

        if (filterMode === 'portfolio') {
            if (selectedPortfolioIndices.size > 0) {
                const portfolioTrades = [];
                selectedPortfolioIndices.forEach(index => portfolioTrades.push(...rawStrategiesData[index]));
                filterSourceTrades = portfolioTrades;
            }
        } else if (filterMode !== '-1') {
            const filterIndex = parseInt(filterMode);
            filterSourceTrades = rawStrategiesData[filterIndex];
        }

        const isRiskNormalized = normalizeRiskCheckbox.checked;
        const targetMaxDD = isRiskNormalized ? parseFloat(document.getElementById('target-max-dd').value) : 0;

        let allAnalysisResults = rawStrategiesData.map((strategyData, i) => ({
            name: loadedStrategyFiles[i].name.replace('.csv', ''),
            analysis: (() => {
                let tradesForAnalysis = strategyData;
                if (isRiskNormalized && targetMaxDD > 0) {
                    const preAnalysis = processStrategyData(strategyData, rawBenchmarkData, filterSourceTrades);
                    if (preAnalysis && preAnalysis.metrics.maxDrawdownInDollars > 0) {
                        const scaleFactor = targetMaxDD / preAnalysis.metrics.maxDrawdownInDollars;
                        tradesForAnalysis = strategyData.map(trade => ({ ...trade, pnl: trade.pnl * scaleFactor }));
                    }
                }
                return processStrategyData(tradesForAnalysis, rawBenchmarkData, filterSourceTrades);
            })(),
            originalIndex: i,
            isSavedPortfolio: false,
            isCurrentPortfolio: false,
        }));
        
        savedPortfolios.forEach((p, i) => {
            const weights = p.weights || Array(p.indices.length).fill(1 / p.indices.length);
            let tradesForAnalysis = [];

            if (weights) {
                const strategyTradeData = p.indices.map(index => rawStrategiesData[index]);
                const scaleFactor = p.riskConfig ? p.riskConfig.scaleFactor : 1;

                strategyTradeData.forEach((trades, strategyIndex) => {
                    const weight = weights[strategyIndex];
                    trades.forEach(trade => {
                        // Apply weight first, then scale the entire portfolio's PnL
                        tradesForAnalysis.push({ ...trade, pnl: (trade.pnl * weight) * scaleFactor });
                    });
                });
            }

            let finalTradesForAnalysis = tradesForAnalysis;
            if (isRiskNormalized && targetMaxDD > 0) {
                const preAnalysis = processStrategyData(tradesForAnalysis, rawBenchmarkData, filterSourceTrades);
                if (preAnalysis && preAnalysis.metrics.maxDrawdownInDollars > 0) {
                    const scaleFactor = targetMaxDD / preAnalysis.metrics.maxDrawdownInDollars;
                    finalTradesForAnalysis = tradesForAnalysis.map(trade => ({ ...trade, pnl: trade.pnl * scaleFactor }));
                }
            }

            const analysis = processStrategyData(finalTradesForAnalysis, rawBenchmarkData, filterSourceTrades);
            
            if(analysis) {
                 allAnalysisResults.push({
                     name: p.name,
                     analysis: analysis,
                     isSavedPortfolio: true,
                     isCurrentPortfolio: false,
                     savedIndex: i,
                     indices: p.indices,
                     weights: p.weights,
                     riskConfig: p.riskConfig
                 });
            }
        });

        if (selectedPortfolioIndices.size > 0) {
            const portfolioTrades = [];
            const equalWeight = 1 / selectedPortfolioIndices.size;
            selectedPortfolioIndices.forEach(index => {
                rawStrategiesData[index].forEach(trade => {
                    portfolioTrades.push({ ...trade, pnl: trade.pnl * equalWeight });
                });
            });

            let finalTradesForAnalysis = portfolioTrades;
            if (isRiskNormalized && targetMaxDD > 0) {
                const preAnalysis = processStrategyData(portfolioTrades, rawBenchmarkData, filterSourceTrades);
                if (preAnalysis && preAnalysis.metrics.maxDrawdownInDollars > 0) {
                    const scaleFactor = targetMaxDD / preAnalysis.metrics.maxDrawdownInDollars;
                    finalTradesForAnalysis = portfolioTrades.map(trade => ({ ...trade, pnl: trade.pnl * scaleFactor }));
                }
            }
            const portfolioAnalysis = processStrategyData(finalTradesForAnalysis, rawBenchmarkData, filterSourceTrades);
            if (portfolioAnalysis) {
                allAnalysisResults.push({ name: 'Portafolio Actual', isPortfolio: true, isCurrentPortfolio: true, analysis: portfolioAnalysis });
            }
        }

        if (comparisonPortfolioIndex !== null && savedPortfolios[comparisonPortfolioIndex]) {
            const portfolioToCompare = savedPortfolios[comparisonPortfolioIndex];
            const originalTrades = portfolioToCompare.indices.flatMap(index => rawStrategiesData[index]);
            
            let finalTradesForAnalysis = originalTrades;
            if (isRiskNormalized && targetMaxDD > 0) {
                const preAnalysis = processStrategyData(originalTrades, rawBenchmarkData, filterSourceTrades);
                if (preAnalysis && preAnalysis.metrics.maxDrawdownInDollars > 0) {
                    const scaleFactor = targetMaxDD / preAnalysis.metrics.maxDrawdownInDollars;
                    finalTradesForAnalysis = originalTrades.map(trade => ({ ...trade, pnl: trade.pnl * scaleFactor }));
                }
            }

            const originalAnalysis = processStrategyData(finalTradesForAnalysis, rawBenchmarkData, filterSourceTrades);

            if (originalAnalysis) {
                allAnalysisResults.push({
                    name: `${portfolioToCompare.name} (Original)`,
                    analysis: originalAnalysis,
                    isSavedPortfolio: true,
                    isTemporaryOriginal: true,
                    savedIndex: 999 + comparisonPortfolioIndex // unique index for color
                });
            }
        }
        
        // destroyAllCharts(); // OPTIMIZATION: We will update charts instead of destroying them
        displayResults(allAnalysisResults);
    };

    tabContentArea.addEventListener('change', (e) => {
        if(e.target.classList.contains('portfolio-checkbox')) {
            reAnalyzeAllData();
            // Update search button indicator when selection changes
            const findModeIndicator = document.getElementById('find-mode-indicator');
            const hasSelection = document.querySelectorAll('.portfolio-checkbox:checked').length > 0;
            findModeIndicator.textContent = hasSelection ? '(B√∫squeda de Complementos)' : '(B√∫squeda Global)';
        }
    });
    
    tabNav.addEventListener('click', (e) => {
        if (e.target.matches('.tab-btn')) {
            const targetId = e.target.dataset.target;
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(targetId).classList.add('active');
            // Render charts for the activated tab on demand
            renderChartsForTab(targetId);
        }
    });

    // --- CORRECCI√ìN: Mover el listener al contenedor correcto ---
    tabContentArea.addEventListener('click', (e) => {
        if (e.target.classList.contains('deselect-strategy-btn')) {
            const indexToDeselect = e.target.dataset.deselectIndex;
            const checkbox = document.querySelector(`.portfolio-checkbox[data-index="${indexToDeselect}"]`);
            if (checkbox) {
                checkbox.checked = false;
                reAnalyzeAllData();
            }
        }
    });

    // --- NUEVO: Listener para el buscador de estrategias en la tabla de resumen ---
    tabContentArea.addEventListener('input', (e) => {
        if (e.target.id === 'strategy-search-input') {
            const searchTerm = e.target.value.toLowerCase();
            const tableBody = document.querySelector('#summary-table tbody');
            if (!tableBody) return;

            tableBody.querySelectorAll('tr').forEach(row => {
                const strategyName = row.cells[1]?.textContent.toLowerCase() || '';
                row.style.display = strategyName.includes(searchTerm) ? '' : 'none';
            });
        }
    });

    redrawChartsBtn.addEventListener('click', () => renderAllCharts(true));

    const createSummaryTab = (results) => {
        const tabId = 'summary';
        const nav = `<button class="tab-btn text-gray-400 py-2 px-4 text-sm font-medium text-center border-b-2 border-transparent" data-target="${tabId}">Resumen Comparativo</button>`;
        
        const allStrategies = results.filter(r => !r.isPortfolio && !r.isSavedPortfolio);
        const selectedStrategies = allStrategies.filter(r => selectedPortfolioIndices.has(r.originalIndex));

        let selectedSummaryHTML = '';
        if (selectedStrategies.length > 0) {
             const names = selectedStrategies.map(s => `
                <div class="relative group bg-gray-700 text-sky-300 text-xs font-medium me-2 pl-2.5 pr-3 py-1 rounded-full flex items-center gap-2">
                    <span>${s.name}</span>
                    <button data-deselect-index="${s.originalIndex}" class="deselect-strategy-btn absolute -top-1.5 -right-1.5 bg-red-600 text-white rounded-full h-5 w-5 flex items-center justify-center text-sm font-bold opacity-0 group-hover:opacity-100 transition-opacity" title="Deseleccionar">&times;</button>
                </div>
             `).join('');

             selectedSummaryHTML = `<div class="mb-6"><h3 class="text-lg font-bold text-white mb-2">Estrategias Seleccionadas para An√°lisis</h3><div id="selected-strategies-list" class="flex flex-wrap gap-2">${names}</div></div>`;
        }

        let tableBodyRows = '';
        results.filter(r => !r.isPortfolio && !r.isSavedPortfolio).forEach((result) => {
            const metrics = result.analysis.metrics;
            const isChecked = selectedPortfolioIndices.has(result.originalIndex) ? 'checked' : '';
            const sharpeText = isFinite(metrics.sharpeRatio) ? metrics.sharpeRatio.toFixed(2) : '‚àû';
            const profitFactorText = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : '‚àû';
            const sortinoText = isFinite(metrics.sortinoRatio) ? metrics.sortinoRatio.toFixed(2) : '‚àû';
            const upiText = isFinite(metrics.upi) ? metrics.upi.toFixed(2) : '‚àû';
            const captureRatioText = isFinite(metrics.captureRatio) ? metrics.captureRatio.toFixed(2) : '‚àû';
            const profitMaxDDRatioText = isFinite(metrics.profitMaxDD_Ratio) ? metrics.profitMaxDD_Ratio.toFixed(2) : '‚àû';
            const monthlyProfitToDollarDDText = isFinite(metrics.monthlyProfitToDollarDD) ? metrics.monthlyProfitToDollarDD.toFixed(2) : '‚àû';
            tableBodyRows += `<tr class="border-b border-gray-700 hover:bg-gray-800"><td class="p-3 w-8"><input type="checkbox" data-index="${result.originalIndex}" class="portfolio-checkbox form-checkbox h-5 w-5 bg-gray-800 border-gray-600 rounded text-sky-500 focus:ring-sky-600" ${isChecked}></td><td class="p-3 font-semibold"><span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color:${STRATEGY_COLORS[result.originalIndex % STRATEGY_COLORS.length]}"></span>${result.name}</td><td class="p-3 text-right">${profitFactorText}</td><td class="p-3 text-right">${sharpeText}</td><td class="p-3 text-right">${sortinoText}</td><td class="p-3 text-right">${upiText}</td><td class="p-3 text-right">${captureRatioText}</td><td class="p-3 text-right">${metrics.maxStagnationTrades}</td><td class="p-3 text-right">${metrics.maxConsecutiveLosses}</td><td class="p-3 text-right">${metrics.maxConsecutiveWins}</td><td class="p-3 text-right">${metrics.maxDrawdown.toFixed(2)}%</td><td class="p-3 text-right">${metrics.maxDrawdownInDollars.toFixed(2)}</td><td class="p-3 text-right">${metrics.monthlyAvgProfit.toFixed(0)}</td><td class="p-3 text-right">${profitMaxDDRatioText}</td><td class="p-3 text-right">${monthlyProfitToDollarDDText}</td><td class="p-3 text-right">${metrics.maxConsecutiveLosingMonths.toFixed(0)}</td><td class="p-3 text-right">${metrics.winningPercentage.toFixed(2)}%</td><td class="p-3 text-right">${metrics.avgWin.toFixed(2)}</td><td class="p-3 text-right">${metrics.avgLoss.toFixed(2)}</td></tr>`;
        });

        let tableFoot = '';
        const portfolioResult = results.find(r => r.isCurrentPortfolio);
        if (portfolioResult) {
            const metrics = portfolioResult.analysis.metrics;
            const sharpeText = isFinite(metrics.sharpeRatio) ? metrics.sharpeRatio.toFixed(2) : '‚àû';
            const profitFactorText = isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : '‚àû';
            const sortinoText = isFinite(metrics.sortinoRatio) ? metrics.sortinoRatio.toFixed(2) : '‚àû';
            const upiText = isFinite(metrics.upi) ? metrics.upi.toFixed(2) : '‚àû';
            const captureRatioText = isFinite(metrics.captureRatio) ? metrics.captureRatio.toFixed(2) : '‚àû';
            const profitMaxDDRatioText = isFinite(metrics.profitMaxDD_Ratio) ? metrics.profitMaxDD_Ratio.toFixed(2) : '‚àû';
            const monthlyProfitToDollarDDText = isFinite(metrics.monthlyProfitToDollarDD) ? metrics.monthlyProfitToDollarDD.toFixed(2) : '‚àû';
            tableFoot = `<tfoot><tr class="border-t-2 border-sky-500 bg-gray-800/50"><td class="p-3 w-8 text-center font-bold text-amber-400">P</td><td class="p-3 font-semibold text-amber-400"><span class="inline-block w-3 h-3 rounded-full mr-2" style="background-color:#f59e0b"></span>${portfolioResult.name}</td><td class="p-3 text-right font-semibold text-amber-400">${profitFactorText}</td><td class="p-3 text-right font-semibold text-amber-400">${sharpeText}</td><td class="p-3 text-right font-semibold text-amber-400">${sortinoText}</td><td class="p-3 text-right font-semibold text-amber-400">${upiText}</td><td class="p-3 text-right font-semibold text-amber-400">${captureRatioText}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.maxStagnationTrades}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.maxConsecutiveLosses}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.maxConsecutiveWins}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.maxDrawdown.toFixed(2)}%</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.maxDrawdownInDollars.toFixed(2)}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.monthlyAvgProfit.toFixed(0)}</td><td class="p-3 text-right font-semibold text-amber-400">${profitMaxDDRatioText}</td><td class="p-3 text-right font-semibold text-amber-400">${monthlyProfitToDollarDDText}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.maxConsecutiveLosingMonths.toFixed(0)}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.winningPercentage.toFixed(2)}%</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.avgWin.toFixed(2)}</td><td class="p-3 text-right font-semibold text-amber-400">${metrics.avgLoss.toFixed(2)}</td></tr></tfoot>`;
        }
        const searchBoxHTML = `
            <div class="mb-4">
                <label for="strategy-search-input" class="block text-sm font-semibold text-gray-300 mb-1">Buscar Estrategia en la Tabla:</label>
                <input type="text" id="strategy-search-input" placeholder="Escribe para filtrar por nombre..." class="w-full bg-gray-900/50 border border-gray-600 text-white text-sm rounded-lg focus:ring-sky-500 focus:border-sky-500 block p-2.5">
            </div>
        `;
        const comparativeTableHTML = `<div>${selectedSummaryHTML}<h2 class="text-2xl font-bold text-white mb-4">Tabla Comparativa de Estrategias</h2>${searchBoxHTML}<div class="overflow-x-auto bg-gray-800 rounded-lg border border-gray-700"><table id="summary-table" class="w-full text-sm text-left"><thead class="bg-gray-700 text-xs text-gray-400 uppercase"><tr><th class="p-3"></th><th class="p-3 sortable" data-column="1">Estrategia</th><th class="p-3 text-right sortable" data-column="2" data-type="numeric">Profit Factor</th><th class="p-3 text-right sortable" data-column="3" data-type="numeric">Coef. Sharpe</th><th class="p-3 text-right sortable" data-column="4" data-type="numeric">Sortino</th><th class="p-3 text-right sortable" data-column="5" data-type="numeric">UPI</th><th class="p-3 text-right sortable" data-column="6" data-type="numeric">Capture Ratio</th><th class="p-3 text-right sortable" data-column="7" data-type="numeric">Stagnation (trades)</th><th class="p-3 text-right sortable" data-column="8" data-type="numeric">P√©rdidas Cons.</th><th class="p-3 text-right sortable" data-column="9" data-type="numeric">Ganadas Cons.</th><th class="p-3 text-right sortable" data-column="10" data-type="numeric">Max DD (%)</th><th class="p-3 text-right sortable" data-column="11" data-type="numeric">Max DD ($)</th><th class="p-3 text-right sortable" data-column="12" data-type="numeric">Profit/Mes</th><th class="p-3 text-right sortable" data-column="13" data-type="numeric">Ratio Profit/DD</th><th class="p-3 text-right sortable" data-column="14" data-type="numeric">Profit Mes/DD($)</th><th class="p-3 text-right sortable" data-column="15" data-type="numeric">Meses P√©rd. Cons. (Max)</th><th class="p-3 text-right sortable" data-column="16" data-type="numeric">Win %</th><th class="p-3 text-right sortable" data-column="17" data-type="numeric">Avg. Win</th><th class="p-3 text-right sortable" data-column="18" data-type="numeric">Avg. Loss</th></tr></thead><tbody>${tableBodyRows}</tbody>${tableFoot}</table></div></div>`;
        const equityChartHTML = `<div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h2 class="text-xl font-bold text-white mb-4">Curvas de Equity (Estrategias Seleccionadas)</h2><div class="h-96"><canvas id="summaryEquityChart"></canvas></div></div>`;
        
        const strategiesToDisplayForCorr = selectedStrategies.length > 0 ? selectedStrategies : allStrategies;
        let correlationMatrixHTML = '';
        if (strategiesToDisplayForCorr.length > 1) {
            const matrix = calculateCorrelationMatrix(strategiesToDisplayForCorr);
            let headers = '<th></th>';
            strategiesToDisplayForCorr.forEach(s => headers += `<th class="p-2 text-center font-semibold">${s.name}</th>`);
            let rows = '';
            strategiesToDisplayForCorr.forEach((s1, i) => {
                let cells = `<td class="corr-header">${s1.name}</td>`;
                strategiesToDisplayForCorr.forEach((s2, j) => {
                    const value = matrix[i][j];
                    const color = getCorrelationColor(value);
                    cells += `<td class="corr-cell" style="background-color:${color};">${value.toFixed(2)}</td>`;
                });
                rows += `<tr>${cells}</tr>`;
            });
            correlationMatrixHTML = `<div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h2 class="text-xl font-bold text-white mb-4">Matriz de Correlaci√≥n (Estrategias Seleccionadas)</h2><div class="overflow-x-auto"><table class="w-full border-collapse"><thead><tr>${headers}</tr></thead><tbody>${rows}</tbody></table></div></div>`;
        }
        const content = `<div id="${tabId}" class="tab-content space-y-8">${comparativeTableHTML}${equityChartHTML}${correlationMatrixHTML}</div>`;
        return { nav, content };
    };
    
    const createStrategyTab = (result) => {
        if (result.isPortfolio || result.isSavedPortfolio) return { nav: '', content: '' };
        
        const tabId = `strategy-${result.originalIndex}`;
        const nav = `<button id="${tabId}-btn" class="tab-btn text-gray-400 py-2 px-4 text-sm font-medium text-center border-b-2 border-transparent" data-target="${tabId}">${result.name}</button>`;
        const metrics = result.analysis.metrics;
        const metricsHTML = `<div><h2 class="text-2xl font-bold text-white mb-4">M√©tricas Clave: ${result.name}</h2><div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-4"><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Profit Factor</h3><p class="text-3xl font-bold">${isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : '‚àû'}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Coef. Sharpe</h3><p class="text-3xl font-bold">${isFinite(metrics.sharpeRatio) ? metrics.sharpeRatio.toFixed(2) : '‚àû'}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Max DD</h3><p class="text-3xl font-bold text-red-400">${metrics.maxDrawdown.toFixed(2)}%</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Profit Prom./Mes</h3><p class="text-3xl font-bold">${metrics.monthlyAvgProfit.toFixed(0)}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Ratio Profit/DD</h3><p class="text-3xl font-bold">${isFinite(metrics.profitMaxDD_Ratio) ? metrics.profitMaxDD_Ratio.toFixed(2) : '‚àû'}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Profit Mes/DD($)</h3><p class="text-3xl font-bold">${isFinite(metrics.monthlyProfitToDollarDD) ? metrics.monthlyProfitToDollarDD.toFixed(2) : '‚àû'}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Win %</h3><p class="text-3xl font-bold">${metrics.winningPercentage.toFixed(2)}%</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Avg. Win</h3><p class="text-3xl font-bold text-green-400">${metrics.avgWin.toFixed(2)}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Avg. Loss</h3><p class="text-3xl font-bold text-red-400">${metrics.avgLoss.toFixed(2)}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">P√©rdidas Cons.</h3><p class="text-3xl font-bold">${metrics.maxConsecutiveLosses}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Ganadas Cons.</h3><p class="text-3xl font-bold">${metrics.maxConsecutiveWins}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Stagnation</h3><p class="text-3xl font-bold">${metrics.maxStagnationTrades}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Meses P√©rd. Cons. (Max)</h3><p class="text-3xl font-bold">${metrics.maxConsecutiveLosingMonths.toFixed(0)}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Capture Ratio</h3><p class="text-3xl font-bold ${metrics.captureRatio > 1.5 ? 'text-green-400' : 'text-gray-300'}">${isFinite(metrics.captureRatio) ? metrics.captureRatio.toFixed(2) : '‚àû'}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">Sortino</h3><p class="text-3xl font-bold">${isFinite(metrics.sortinoRatio) ? metrics.sortinoRatio.toFixed(2) : '‚àû'}</p></div><div class="bg-gray-800 p-4 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400 text-sm">UPI</h3><p class="text-3xl font-bold">${isFinite(metrics.upi) ? metrics.upi.toFixed(2) : '‚àû'}</p></div></div></div>`;
        const conditionalHTML = `<div><h2 class="text-2xl font-bold text-white mb-4">An√°lisis Condicional</h2><div class="grid grid-cols-1 sm:grid-cols-2 gap-6"><div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400">Rendimiento Medio en D√≠as Bajistas</h3><p class="text-4xl font-bold ${metrics.avgPortfolioReturnOnDownDays * 100 >= -0.05 ? 'text-green-400' : 'text-red-400'}">${(metrics.avgPortfolioReturnOnDownDays * 100).toFixed(2)}%</p></div><div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h3 class="font-semibold text-gray-400">Rendimiento Medio en D√≠as Alcistas</h3><p class="text-4xl font-bold ${metrics.avgPortfolioReturnOnUpDays * 100 > 0 ? 'text-green-400' : 'text-red-400'}">${(metrics.avgPortfolioReturnOnUpDays * 100).toFixed(2)}%</p></div></div></div>`;
        let rollingSortinoHTML = '';
        if (result.analysis.rollingSortinoData.length > 0) {
            rollingSortinoHTML = `<div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h2 class="text-xl font-bold">Sortino M√≥vil (1 A√±o)</h2><div class="h-80"><canvas id="rollingSortinoChart-${tabId}"></canvas></div></div>`;
        }
        const chartsHTML = `<div class="grid grid-cols-1 xl:grid-cols-2 gap-8"><div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700 xl:col-span-2"><h2 class="text-xl font-bold">Equity vs. Benchmark</h2><div class="h-96"><canvas id="equityChart-${tabId}"></canvas></div></div><div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h2 class="text-xl font-bold">Dispersi√≥n de Rendimientos</h2><div class="h-80"><canvas id="scatterChart-${tabId}"></canvas></div></div><div class="bg-gray-800 p-6 rounded-xl shadow-lg border border-gray-700"><h2 class="text-xl font-bold">Curva de Lorenz</h2><div class="h-80"><canvas id="lorenzChart-${tabId}"></canvas></div></div>${rollingSortinoHTML}</div>`;
        const content = `<div id="${tabId}" class="tab-content space-y-8">${metricsHTML}${conditionalHTML}${chartsHTML}</div>`;
        return { nav, content };
    };
    
    const renderPortfolioComparisonCharts = (portfolioAnalyses) => {
        const canvasId = 'portfolioEquityChart';
        destroyChart(canvasId);
        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx) return;

        // Show the chart section if there are portfolios to show
        if (portfolioAnalyses.length > 0 || comparisonPortfolioIndex !== null) {
            portfolioComparisonChartSection.classList.remove('hidden');
        } else {
            portfolioComparisonChartSection.classList.add('hidden');
            return; // No need to render if there's nothing to show
        }


        const allAnalyses = [...portfolioAnalyses];
        const originalResult = window.analysisResults.find(r => r.isTemporaryOriginal);
        if (originalResult) {
            // Ensure it's not already in the list to avoid duplicates
            if (!allAnalyses.some(a => a.name === originalResult.name)) {
                 allAnalyses.push(originalResult);
            }
        }

        if (allAnalyses.length === 0) return;

        const datasets = allAnalyses.map((result) => {
            const isFeatured = result.savedIndex === featuredPortfolioIndex;
            const portfolio = result.analysis.portfolioValues;
            const normalized = portfolio.map(v => (v / (portfolio[0] || 1)) * 100);
            const dataset = {
                label: result.name,
                data: normalized,
                borderColor: isFeatured ? '#fbbf24' : (result.isTemporaryOriginal ? '#9ca3af' : STRATEGY_COLORS[(4 + result.savedIndex) % STRATEGY_COLORS.length]),
                borderWidth: isFeatured ? 3 : 2,
                pointRadius: 0,
                tension: 0.1,
                savedIndex: result.savedIndex,
                order: isFeatured ? 0 : 1 // Dibuja el destacado encima
            };
            return { ...dataset, data: result.analysis.labels.map((label, i) => ({ x: label, y: normalized[i] })) };
        });
        
        const firstAnalysis = allAnalyses[0].analysis;
        datasets.push({ label: 'Benchmark', data: firstAnalysis.benchmarkData.map(d => ({x: d.x, y: (d.y / (firstAnalysis.benchmarkData[0].y || 1)) * 100})), borderColor: '#f87171', borderWidth: 2, pointRadius: 0, tension: 0.1, borderDash: [5, 5] });
        const options = { ...chartOptions };

        // --- OPTIMIZATION: Update existing chart if possible ---
        if (chartInstances[canvasId]) {
            const chart = chartInstances[canvasId];
            chart.data.datasets = datasets;
            chart.update();
            // Re-attach handlers as they might be lost on update
            chart.options.onHover = options.onHover;
            chart.options.onClick = options.onClick;
            return;
        }
        // --- END OPTIMIZATION ---

        options.onHover = (event, chartElement, chart) => {
            chart.canvas.style.cursor = chartElement[0] ? 'pointer' : 'default';
            const datasets = chart.data.datasets;
            
            // Reset all to default state first
            const isFeaturedActive = datasets.some(d => d.borderWidth > 2);
            if (!isFeaturedActive) { // Only reset if nothing is actively hovered
                // This part is tricky, let's simplify by just highlighting
            }

            datasets.forEach((dataset, i) => {
                dataset.borderWidth = 2;
                if(dataset.hasOwnProperty('savedIndex')) {
                    if (dataset.savedIndex >= 999) { // Temporary original
                        dataset.borderColor = '#9ca3af';
                    } else {
                        dataset.borderColor = STRATEGY_COLORS[(4 + dataset.savedIndex) % STRATEGY_COLORS.length];
                    }
                }
            });

            if (chartElement.length > 0) {
                const index = chartElement[0].datasetIndex;
                if(datasets[index].hasOwnProperty('savedIndex')){
                    datasets[index].borderWidth = 4;
                    datasets.forEach((dataset, i) => {
                         if(i !== index && dataset.hasOwnProperty('savedIndex')) {
                             dataset.borderColor = '#4b5563'; // gray-600
                         }
                    });
                }
            }
            chart.update('none');
        };

        options.onClick = (event, elements, chart) => {
            if (elements.length > 0) {
                const clickedIndex = elements[0].datasetIndex;
                const dataset = chart.data.datasets[clickedIndex];
                if (dataset.hasOwnProperty('savedIndex') && dataset.savedIndex < 999) { // Ensure it's a portfolio line
                    const action = document.querySelector('#chart-actions-group .chart-action-item.active')?.dataset.action || 'destacar';
                    const savedIndex = dataset.savedIndex;
                    
                    console.log(`Clic en CURVA del portafolio ${savedIndex}. Acci√≥n seleccionada: '${action}'`);

                    switch(action) {
                        case 'editar':
                            openOptimizationModal(savedIndex);
                            break;
                        case 'ocultar':
                            // This action is better handled by legend click
                            break;
                        default: // 'destacar'
                            openChartClickModal(savedIndex);
                    }
                }
            }
        };

        // Add event listeners for the new chart actions menu
        setTimeout(() => {
            document.querySelectorAll('#chart-actions-group .chart-action-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    document.querySelectorAll('#chart-actions-group .chart-action-item').forEach(i => i.classList.remove('active'));
                    item.classList.add('active');
                });
            });
        }, 0);

        chartInstances[canvasId] = new Chart(ctx, { type: 'line', data: { datasets: datasets }, options: options });
    };

    Chart.defaults.color = '#9ca3af';
    Chart.defaults.borderColor = '#4b5563';
    Chart.defaults.font.family = "'Inter', sans-serif";

    const renderSummaryEquityChart = (results) => {
        const canvasId = 'summaryEquityChart';
        destroyChart(canvasId);
        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx || !results || results.length === 0) return;

        const firstAnalysis = results[0].analysis;
        const datasets = results.map((result) => {
            const portfolio = result.analysis.portfolioValues;
            const normalized = portfolio.map(v => (v / (portfolio[0] || 1)) * 100);
            return { label: result.name, data: result.analysis.labels.map((l, i) => ({x: l, y: normalized[i]})), borderColor: STRATEGY_COLORS[result.originalIndex % STRATEGY_COLORS.length], borderWidth: 2, pointRadius: 0, tension: 0.1 };
        });

        datasets.push({ label: 'Benchmark', data: firstAnalysis.benchmarkData.map(d => ({x: d.x, y: (d.y / (firstAnalysis.benchmarkData[0].y || 1)) * 100})), borderColor: '#f87171', borderWidth: 2, pointRadius: 0, tension: 0.1, borderDash: [5, 5] });

        // --- OPTIMIZATION: Update existing chart if possible ---
        if (chartInstances[canvasId]) {
            chartInstances[canvasId].data.datasets = datasets;
            chartInstances[canvasId].update();
            return;
        }
        // --- END OPTIMIZATION ---

        chartInstances[canvasId] = new Chart(ctx, { type: 'line', data: { datasets: datasets }, options: chartOptions });
    };

    const renderEquityChart = (canvasId, analysis, name, color) => {
        const datasets = [
            { label: name, data: analysis.labels.map((l, i) => ({x: l, y: (analysis.portfolioValues[i] / (analysis.portfolioValues[0] || 1)) * 100})), borderColor: color, backgroundColor: `${color}1a`, borderWidth: 2, pointRadius: 0, tension: 0.1, fill: true },
            { label: 'Benchmark', data: analysis.benchmarkData.map(d => ({x: d.x, y: (d.y / (analysis.benchmarkData[0].y || 1)) * 100})), borderColor: '#f87171', backgroundColor: '#f871711a', borderWidth: 2, pointRadius: 0, tension: 0.1, fill: true }
        ];

        // --- OPTIMIZATION: Update existing chart if possible ---
        if (chartInstances[canvasId]) {
            chartInstances[canvasId].data.datasets = datasets;
            chartInstances[canvasId].update();
            return;
        }
        // --- END OPTIMIZATION ---

        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx) return;
        const normalizedPortfolio = analysis.portfolioValues.map(v => (v / (analysis.portfolioValues[0] || 1)) * 100);
        const portfolioData = analysis.labels.map((l, i) => ({x: l, y: normalizedPortfolio[i]}));
        const benchmarkData = analysis.benchmarkData.map(d => ({x: d.x, y: (d.y / (analysis.benchmarkData[0].y || 1)) * 100}));
        chartInstances[canvasId] = new Chart(ctx, { type: 'line', data: { datasets: [ { label: name, data: portfolioData, borderColor: color, backgroundColor: `${color}1a`, borderWidth: 2, pointRadius: 0, tension: 0.1, fill: true }, { label: 'Benchmark', data: benchmarkData, borderColor: '#f87171', backgroundColor: '#f871711a', borderWidth: 2, pointRadius: 0, tension: 0.1, fill: true } ] }, options: chartOptions });
    };
    
    const renderScatterChart = (canvasId, analysis, color) => {
        destroyChart(canvasId);
        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx) return;
        chartInstances[canvasId] = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Rendimiento Diario',
                    data: analysis.returnsData,
                    backgroundColor: `${color}99`
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    x: {
                        ...chartOptions.scales.x,
                        title: {
                            display: true,
                            text: 'Rendimiento Benchmark (%)',
                            color: '#d1d5db'
                        }
                    },
                    y: {
                        ...chartOptions.scales.y,
                        title: {
                            display: true,
                            text: 'Rendimiento Estrategia (%)',
                            color: '#d1d5db'
                        }
                    }
                }
            }
        });
    };
    const renderLorenzChart = (canvasId, analysis, color) => {
        destroyChart(canvasId);
        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx) return;
        chartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Curva de Beneficios',
                    data: analysis.lorenzData,
                    showLine: true,
                    borderColor: color,
                    backgroundColor: `${color}1a`,
                    tension: .1,
                    pointRadius: 0,
                    fill: true
                }, {
                    label: 'Consistencia Perfecta',
                    data: [{x: 0, y: 0}, {x: 100, y: 100}],
                    borderColor: '#4ade80',
                    borderWidth: 2,
                    pointRadius: 0,
                    borderDash: [5, 5],
                    fill: false
                }]
            },
            options: {
                ...chartOptions,
                scales: {
                    x: {
                        ...chartOptions.scales.x,
                        type: 'linear',
                        position: 'bottom',
                        min: 0,
                        max: 100,
                        title: {
                            display: true,
                            text: '% Acumulado de Trades Ganadores'
                        }
                    },
                    y: {
                        ...chartOptions.scales.y,
                        min: 0,
                        max: 100,
                        title: {
                            display: true,
                            text: '% Acumulado del Beneficio Total'
                        }
                    }
                }
            }
        });
    };

    const renderRollingSortinoChart = (canvasId, analysis, color) => {
        destroyChart(canvasId);
        const ctx = document.getElementById(canvasId)?.getContext('2d');
        if (!ctx) return;
        chartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Sortino M√≥vil (1A)',
                    data: analysis.rollingSortinoData,
                    borderColor: color,
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                }]
            },
            options: chartOptions
        });
    };

    const calculateCorrelationMatrix = (strategies) => {
        const allDates = new Set();
        strategies.forEach(s => s.analysis.dailyReturnsMap.forEach((_, date) => allDates.add(date)));
        const sortedDates = Array.from(allDates).sort();

        const returnVectors = strategies.map(s => {
            return sortedDates.map(date => s.analysis.dailyReturnsMap.get(date) || 0);
        });

        const matrix = Array(strategies.length).fill(0).map(() => Array(strategies.length).fill(0));

        for (let i = 0; i < strategies.length; i++) {
            for (let j = i; j < strategies.length; j++) {
                const corr = pearsonCorrelation(returnVectors[i], returnVectors[j]);
                matrix[i][j] = corr;
                matrix[j][i] = corr;
            }
        }
        return matrix;
    };

    const pearsonCorrelation = (x, y) => {
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
        const n = x.length;
        for (let i = 0; i < n; i++) {
            sumX += x[i];
            sumY += y[i];
            sumXY += x[i] * y[i];
            sumX2 += x[i] * x[i];
            sumY2 += y[i] * y[i];
        }
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        if (denominator === 0) return 0;
        return numerator / denominator;
    };

    const getCorrelationColor = (value) => {
        if (value === 1) return '#4b5563'; // Gray for diagonal
        const hue = (1 - value) * 60;
        return `hsl(${hue}, 90%, 40%)`;
    };

    const chartOptions = { maintainAspectRatio: false, responsive: true, plugins: { legend: { position: 'top', labels: { color: '#e5e7eb' } }, zoom: { pan: { enabled: true, mode: 'x' }, zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' } } }, scales: { x: { type: 'timeseries', time: { unit: 'month' }, ticks: { color: '#9ca3af', autoSkip: true, maxTicksLimit: 20 }, grid: { color: 'rgba(75, 85, 99, 0.5)' } }, y: { ticks: { color: '#9ca3af' }, grid: { color: 'rgba(75, 85, 99, 0.5)' } } } };

    // Add global legend hover functionality
    chartOptions.plugins.legend.onHover = (event, item, legend) => {
        highlightChartLine(legend.chart, item.datasetIndex);
    };
    chartOptions.plugins.legend.onLeave = (event, item, legend) => {
        highlightChartLine(legend.chart, null);
    };

    // Add global legend click functionality
    chartOptions.plugins.legend.onClick = (event, item, legend) => {
        const action = document.querySelector('#chart-actions-group .chart-action-item.active')?.dataset.action || 'destacar';
        const dataset = legend.chart.data.datasets[item.datasetIndex];

        if (dataset.hasOwnProperty('savedIndex') && dataset.savedIndex < 999) {
            const savedIndex = dataset.savedIndex;
            console.log(`Clic en LEYENDA del portafolio ${savedIndex}. Acci√≥n seleccionada: '${action}'`);

            switch(action) {
                case 'editar':
                    openOptimizationModal(savedIndex);
                    break;
                case 'destacar':
                    openChartClickModal(savedIndex);
                    break;
                default: // 'ocultar'
                    // Default Chart.js behavior to toggle visibility
                    Chart.defaults.plugins.legend.onClick.call(this, event, item, legend);
            }
        } else {
            // Default behavior for non-portfolio items (like Benchmark)
            Chart.defaults.plugins.legend.onClick.call(this, event, item, legend);
        }
    };

    const sortTable = (header) => {
        const table = header.closest('table');
        if (!table) return;
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const column = parseInt(header.dataset.column, 10);
        const type = header.dataset.type;
        
        const currentOrder = header.dataset.order;
        const newOrder = currentOrder === 'asc' ? 'desc' : 'asc';
        const direction = newOrder === 'asc' ? 1 : -1;

        table.querySelectorAll('th.sortable').forEach(th => th.removeAttribute('data-order'));
        header.dataset.order = newOrder;

        const rows = Array.from(tbody.querySelectorAll('tr'));
        
        rows.sort((a, b) => {
            let aVal = a.children[column].textContent.trim();
            let bVal = b.children[column].textContent.trim();
            
            if (type === 'numeric') {
                aVal = parseFloat(aVal.replace(/[%‚àû]/g, '')) || (aVal.includes('‚àû') ? Infinity : -Infinity);
                bVal = parseFloat(bVal.replace(/[%‚àû]/g, '')) || (bVal.includes('‚àû') ? Infinity : -Infinity);
            }

            if (aVal < bVal) return -1 * direction;
            if (aVal > bVal) return 1 * direction;
            return 0;
        });

        rows.forEach(row => tbody.appendChild(row));
    };

    // --- L√≥gica para buscar y guardar los mejores porfolios ---
    const countCombinations = (n, minSize, maxSize) => {
¬† ¬† ¬† ¬† const combinations = (n_c, k_c) => {
¬† ¬† ¬† ¬† ¬† ¬† if (k_c < 0 || k_c > n_c) return 0;
¬† ¬† ¬† ¬† ¬† ¬† if (k_c === 0 || k_c === n_c) return 1;
¬† ¬† ¬† ¬† ¬† ¬† if (k_c > n_c / 2) k_c = n_c - k_c; // Optimizaci√≥n
¬† ¬† ¬† ¬† ¬† ¬† let res = 1;
¬† ¬† ¬† ¬† ¬† ¬† for (let i = 1; i <= k_c; i++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† res = res * (n_c - i + 1) / i;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† return Math.round(res);
¬† ¬† ¬† ¬† };

¬† ¬† ¬† ¬† let total = 0;
¬† ¬† ¬† ¬† for (let k = minSize; k <= maxSize; k++) {
¬† ¬† ¬† ¬† ¬† ¬† total += combinations(n, k);
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† return total;
¬† ¬† };

    function* getCombinations(arr, minSize = 2, maxSize = arr.length) {
¬† ¬† ¬† ¬† function* combine(startIndex, currentCombination, k) {
¬† ¬† ¬† ¬† ¬† ¬† if (currentCombination.length === k) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† yield [...currentCombination];
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† if (startIndex === arr.length) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† return;
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† ¬† for (let i = startIndex; i < arr.length; i++) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† currentCombination.push(arr[i]);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† yield* combine(i + 1, currentCombination, k);
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† currentCombination.pop();
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† }

¬† ¬† ¬† ¬† for (let k = minSize; k <= maxSize; k++) {
¬† ¬† ¬† ¬† ¬† ¬† yield* combine(0, [], k);
¬† ¬† ¬† ¬† }
¬† ¬† }    
    
    
    const displaySavedPortfoliosList = () => {
        if (savedPortfolios.length === 0) {
            savedPortfoliosSection.classList.add('hidden');
            return;
        }
        
        if (savedPortfolios.length > 0) {
            portfolioComparisonChartSection.classList.remove('hidden');
        } else {
            portfolioComparisonChartSection.classList.add('hidden');
        }

        savedPortfoliosSection.classList.remove('hidden');
        savedPortfoliosCount.textContent = `${savedPortfolios.length} portafolios`;

        // Generate Header
        const activeViewColumns = tableViews.saved[activeViews.saved]?.columns || tableViews.saved['default'].columns;

        let headerHTML = '<tr>';
        activeViewColumns.forEach(key => {
            const colInfo = ALL_METRICS[key];
            if (colInfo) {
                const orderIndicator = savedPortfoliosSortConfig.key === key ? `data-order="${savedPortfoliosSortConfig.order}"` : '';
                if (key === 'name') {
                    headerHTML += `<th class="${colInfo.class} sortable" data-sort-key="${key}" ${orderIndicator}>${colInfo.label}</th>`;
                } else {
                    headerHTML += `<th class="${colInfo.class.replace('text-right', 'text-center')} sortable" data-sort-key="${key}" ${orderIndicator}><div class="corr-header">${colInfo.label}</div></th>`;
                }
            }
        });
        headerHTML += `<th class="p-2 text-center align-bottom">Acciones</th>`;
        headerHTML += '</tr>';
        savedPortfoliosHeader.innerHTML = headerHTML;

        // Sort data before rendering
        const sortedPortfolios = [...savedPortfolios].map((p, i) => ({ ...p, savedIndex: i }));
        const sortKey = savedPortfoliosSortConfig.key;
        const sortOrder = savedPortfoliosSortConfig.order;

        sortedPortfolios.sort((a, b) => {
            let valA, valB;
            if (sortKey === 'name') {
                valA = a.name.toLowerCase();
                valB = b.name.toLowerCase();
            } else {
                const analysisA = window.analysisResults?.find(r => r.isSavedPortfolio && r.savedIndex === a.savedIndex)?.analysis;
                const analysisB = window.analysisResults?.find(r => r.isSavedPortfolio && r.savedIndex === b.savedIndex)?.analysis;
                valA = analysisA ? analysisA.metrics[sortKey] : -Infinity;
                valB = analysisB ? analysisB.metrics[sortKey] : -Infinity;
            }

            if (typeof valA === 'number') {
                valA = isFinite(valA) ? valA : (sortOrder === 'desc' ? -Infinity : Infinity);
                valB = isFinite(valB) ? valB : (sortOrder === 'desc' ? -Infinity : Infinity);
            }

            if (valA < valB) return sortOrder === 'asc' ? -1 : 1;
            if (valA > valB) return sortOrder === 'asc' ? 1 : -1;
            return 0;
        });

        // Generate Body
        let bodyHTML = '';
        sortedPortfolios.forEach((p) => {
            const i = p.savedIndex;
            const portfolioAnalysis = window.analysisResults?.find(r => r.isSavedPortfolio && r.savedIndex === i);
            if (!portfolioAnalysis || !portfolioAnalysis.analysis) return;

            const metrics = portfolioAnalysis.analysis.metrics;
            const weightsText = p.weights ? `(${p.weights.map(w => `${(w*100).toFixed(0)}%`).join('/')})` : '';
            const isFeatured = i === featuredPortfolioIndex;
            const featuredClass = isFeatured ? 'featured' : '';
            const isCompared = i === comparisonPortfolioIndex;
            const compareClass = isCompared ? 'active' : '';

            let rowClass = 'hover:bg-gray-700/50';
            const selectionIndex = selectedRows.saved.indexOf(i);
            if (selectionIndex !== -1) {
                rowClass = SELECTION_COLORS[selectionIndex % SELECTION_COLORS.length];
            }

            let rowHTML = `<tr class="${rowClass} text-xs cursor-pointer" data-row-type="saved" data-row-index="${i}">`;

            activeViewColumns.forEach(key => {
                if (key === 'name') {
                    rowHTML += `<td class="p-2">
                        <p class="font-semibold text-sky-300">${p.name}</p>
                        <p class="text-gray-400">${weightsText}</p>
                    </td>`;
                } else {
                    const value = portfolioAnalysis.analysis.metrics[key];
                    rowHTML += `<td class="p-2 text-right">${formatMetricForDisplay(value, key)}</td>`;
                }
            });

            rowHTML += `<td class="p-2 text-center whitespace-nowrap">
                        <button data-index="${i}" class="feature-portfolio-btn text-gray-500 hover:text-amber-400 text-xl px-1 ${featuredClass}" title="Destacar/Acciones">&#9733;</button>
                        ${p.weights ? `<button data-index="${i}" class="compare-original-btn text-gray-500 hover:text-amber-400 text-xl px-1 ${compareClass}" title="Comparar con Original">üîÑ</button>` : ''}
                        <button data-index="${i}" class="view-edit-portfolio-btn bg-teal-600 hover:bg-teal-700 text-white font-bold py-1 px-2 rounded text-xs">Editar</button>
                        <button data-index="${i}" class="delete-portfolio-btn text-red-500 hover:text-red-400 font-bold text-lg px-1">&times;</button>
                    </td>
                </tr>
            `;
            bodyHTML += rowHTML;
        });
        savedPortfoliosBody.innerHTML = bodyHTML;
    };
    
    savedPortfoliosHeader.addEventListener('click', (e) => {
        const header = e.target.closest('th.sortable');
        if (!header) return;

        const sortKey = header.dataset.sortKey;
        if (savedPortfoliosSortConfig.key === sortKey) {
            savedPortfoliosSortConfig.order = savedPortfoliosSortConfig.order === 'asc' ? 'desc' : 'asc';
        } else {
            const metricsToMinimize = ['maxDrawdown', 'maxStagnationTrades', 'maxConsecutiveLosses', 'avgLoss', 'maxDrawdownInDollars', 'downsideCapture', 'maxConsecutiveLosingMonths'];
            savedPortfoliosSortConfig.key = sortKey;
            savedPortfoliosSortConfig.order = metricsToMinimize.includes(sortKey) ? 'asc' : 'desc';
        }
        displaySavedPortfoliosList();
    });

    savedPortfoliosBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-portfolio-btn')) {
            const indexToRemove = parseInt(e.target.dataset.index, 10);
            if (indexToRemove === featuredPortfolioIndex) {
                featuredPortfolioIndex = null;
            }
            if (indexToRemove === comparisonPortfolioIndex) {
                comparisonPortfolioIndex = null;
            }
            savedPortfolios.splice(indexToRemove, 1);
            reAnalyzeAllData();
        }
         if (e.target.classList.contains('view-edit-portfolio-btn')) {
            const index = parseInt(e.target.dataset.index, 10);
            openOptimizationModal(index);
        }
        if (e.target.classList.contains('feature-portfolio-btn')) {
            const index = parseInt(e.target.dataset.index, 10);
            openChartClickModal(index);
        }
        if (e.target.classList.contains('compare-original-btn')) {
            const index = parseInt(e.target.dataset.index, 10);
            comparisonPortfolioIndex = (comparisonPortfolioIndex === index) ? null : index;
            reAnalyzeAllData();
        }
    });

    optimizationMetricSelect.addEventListener('change', (e) => {
        const selectedMetric = e.target.value;
        const metricsToMinimize = ['downsideCapture', 'maxStagnationTrades', 'maxConsecutiveLosses', 'maxDrawdown', 'maxDrawdownInDollars', 'avgLoss', 'maxConsecutiveLosingMonths'];
        optimizationGoalSelect.value = metricsToMinimize.includes(selectedMetric) ? 'minimize' : 'maximize';
    });

    

    // --- L√≥gica de Importar/Exportar ---

    const exportAnalysis = () => {
        if (rawStrategiesData.length === 0) {
            alert("No hay datos para exportar. Por favor, primero analiza las estrategias.");
            return;
        }

        const state = {
            loadedStrategyFiles: loadedStrategyFiles.map(f => ({ name: f.name })),
            benchmarkFileName: benchmarkFileInput.files[0]?.name || null,
            rawStrategiesData: rawStrategiesData,
            rawBenchmarkData: rawBenchmarkData,
            savedPortfolios: savedPortfolios,
            selectedPortfolioIndices: Array.from(selectedPortfolioIndices),
            featuredPortfolioIndex: featuredPortfolioIndex,
            nextPortfolioId: nextPortfolioId,
            tableViews: tableViews, // Guardar configuraciones de vistas
            activeViews: activeViews, // Guardar vistas activas
            databankPortfolios: databankPortfolios, // <-- A√±ade esta l√≠nea
        };

        const stateString = JSON.stringify(state);
        const blob = new Blob([stateString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `analisis_estrategias_${new Date().toISOString().slice(0,10)}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    const importAnalysis = (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const state = JSON.parse(event.target.result);
                restoreState(state);
            } catch (error) {
                console.error("Error al importar el archivo:", error);
                displayError("El archivo de importaci√≥n no es v√°lido o est√° corrupto.");
            }
        };
        reader.readAsText(file);
    };

    const restoreState = (state) => {
        // Reset manual
        destroyAllCharts();
        savedPortfoliosSection.classList.add('hidden');
        hideError();
        tabNav.innerHTML = '';
        tabContentArea.innerHTML = '';

        // Cargar estado
        loadedStrategyFiles = state.loadedStrategyFiles.map(f => ({ name: f.name, isPlaceholder: true }));
        rawStrategiesData = state.rawStrategiesData;
        rawBenchmarkData = state.rawBenchmarkData;
        savedPortfolios = state.savedPortfolios || [];
        selectedPortfolioIndices = new Set(state.selectedPortfolioIndices || []);
        featuredPortfolioIndex = state.featuredPortfolioIndex !== undefined ? state.featuredPortfolioIndex : null;
        nextPortfolioId = state.nextPortfolioId || (savedPortfolios.length ? Math.max(...savedPortfolios.map(p => p.id || 0)) + 1 : 0);
        tableViews = state.tableViews || { databank: { 'default': { name: 'Vista por Defecto', columns: ['name', 'metricValue', 'profitFactor', 'sortinoRatio', 'maxDrawdown'] } }, saved: { 'default': { name: 'Vista por Defecto', columns: ['name', 'profitFactor', 'sortinoRatio', 'upi', 'maxDrawdown', 'maxConsecutiveLosingMonths'] } } };
        activeViews = state.activeViews || { databank: 'default', saved: 'default' };

        databankPortfolios = state.databankPortfolios || []; // Cargar datos del DataBank


        // Actualizar UI de controles
        updateTradesFilesList();
        benchmarkFileNameEl.textContent = state.benchmarkFileName || '(date, price)';
        populateViewSelector('databank');
        populateViewSelector('saved');
        
        // Lanzar re-an√°lisis
        reAnalyzeAllData();

            // Mostrar y actualizar DataBank si hay datos importados
        if (databankPortfolios && databankPortfolios.length > 0) {
            databankSection.classList.remove('hidden');
            // Asegurarse de que la cabecera de la m√©trica se actualice si es posible
            updateDatabankDisplay(); // Dibuja la tabla primero para que los elementos existan
            const metricHeader = document.getElementById('databank-metric-header');
            if (databankPortfolios[0].metricName) {
                if(metricHeader) metricHeader.textContent = databankPortfolios[0].metricName;
            } else {
                // Si no hay nombre guardado, usar el actual o uno por defecto
                const currentMetricOption = optimizationMetricSelect.options[optimizationMetricSelect.selectedIndex];
                if(metricHeader) metricHeader.textContent = currentMetricOption ? currentMetricOption.text : 'M√©trica Optimizada';
            }
            databankStatus.innerHTML = `‚ÑπÔ∏è DataBank cargado (${databankPortfolios.length} portafolios).`;
            // Deshabilitar controles de b√∫squeda ya que no est√° activa
            pauseSearchBtn.disabled = true;
            stopSearchBtn.disabled = true;
            clearDatabankBtn.disabled = false;
            if (databankSizeInput) databankSizeInput.disabled = false; // Permitir cambiar tama√±o
        } else {
            databankSection.classList.add('hidden'); // Ocultar si no hay datos
        }
    };

    exportBtn.addEventListener('click', exportAnalysis);
    importFile.addEventListener('click', (e) => { e.target.value = null; });
    importFile.addEventListener('change', importAnalysis);

    // --- Portfolio Composition (Weight Optimization) Logic ---

    const openOptimizationModal = (portfolioIndex) => {
        currentOptimizationData = { portfolioIndex };
        const portfolio = savedPortfolios[portfolioIndex];

        optimizationModalTitle.textContent = 'Editar Portafolio';

        // --- Display portfolio composition ---
        const strategyNames = portfolio.indices.map(i => loadedStrategyFiles[i]?.name.replace('.csv', '') || `Estrategia ${i+1}`);
        let compositionHTML = `<p class="font-semibold text-lg text-sky-300 mb-2">${portfolio.name}</p>`;
        compositionHTML += '<p class="text-sm text-gray-400 mb-3">Haz clic en una estrategia para copiar su nombre:</p>';
        compositionHTML += '<ul class="space-y-1">';
        strategyNames.forEach(name => {
            compositionHTML += `
                <li>
                    <span class="copyable-strategy text-gray-300 text-sm p-1 rounded-md transition-colors duration-200" title="Copiar '${name}'">${name}</span>
                </li>
            `;
        });
        compositionHTML += '</ul>';
        optimizationPortfolioNameEl.innerHTML = compositionHTML;

        optimizationResultsContainer.innerHTML = '';
        optimizationResultsContainer.classList.add('hidden');
        optimizationSetupContainer.classList.remove('hidden');

        // Populate dropdown for new optimization
        optimizationTargetMetricSelect.innerHTML = optimizationMetricSelect.innerHTML;
        optimizationTargetMetricSelect.value = 'sortinoRatio';
        optimizationTargetGoalSelect.value = 'maximize';

        // --- Calculate Analyses for Display ---

        // 1. Calculate TRUE original (equal weighted) analysis to use as the baseline
        const equalWeight = 1 / portfolio.indices.length;
        const equalWeights = Array(portfolio.indices.length).fill(equalWeight);
        const equalWeightedTrades = [];
        portfolio.indices.forEach(index => {
            rawStrategiesData[index].forEach(trade => {
                equalWeightedTrades.push({ ...trade, pnl: trade.pnl * equalWeight });
            });
        });
        const trueOriginalAnalysis = processStrategyData(equalWeightedTrades, rawBenchmarkData);

        // 2. Determine the "current" analysis to display
        let currentAnalysis, currentWeights;
        if (portfolio.weights) {
            // It's an already optimized portfolio, use its weights
            currentWeights = portfolio.weights;
            const weightedTrades = [];
            const portfolioTradesData = portfolio.indices.map(index => rawStrategiesData[index]);
            portfolioTradesData.forEach((strategyTrades, index) => {
                strategyTrades.forEach(trade => {
                    weightedTrades.push({ ...trade, pnl: trade.pnl * currentWeights[index] });
                });
            });
            currentAnalysis = processStrategyData(weightedTrades, rawBenchmarkData);
        } else {
            // It's an original (equal-weighted) portfolio
            currentWeights = equalWeights;
            currentAnalysis = trueOriginalAnalysis;
        }

        // --- Display Results ---
        displayOptimizationResults({
            baseAnalysis: trueOriginalAnalysis,
            metricBestAnalysis: currentAnalysis,
            balancedBestAnalysis: currentAnalysis, // Use current as placeholder
            portfolio: portfolio,
            metricBestWeights: currentWeights,
            balancedBestWeights: currentWeights,
            optimizationMetricName: portfolio.riskConfig?.optimizationMetric || null
        });

        
        // --- Handle Slider State if it exists ---
        if (portfolio.riskConfig) {
             setTimeout(() => { 
                 const slider = document.getElementById('max-dd-slider');
                 if (slider) {
                     const baseDD95 = portfolio.riskConfig.baseMaxDDInDollars * 1.5;
                     const targetDD95 = baseDD95 * portfolio.riskConfig.scaleFactor;
                     slider.value = targetDD95;
                     slider.dispatchEvent(new Event('input'));
                 }
             }, 10);
        }

        // --- Show Modal ---
        optimizationModal.classList.remove('hidden');
        optimizationModal.classList.add('flex');
        setTimeout(() => {
            optimizationModalBackdrop.classList.remove('opacity-0');
            optimizationModalContent.classList.remove('scale-95', 'opacity-0');
        }, 10);
    };
    
    const closeOptimizationModal = () => {
        optimizationModalBackdrop.classList.add('opacity-0');
        optimizationModalContent.classList.add('scale-95', 'opacity-0');
        setTimeout(() => {
            optimizationModal.classList.add('hidden');
            optimizationModal.classList.remove('flex');
        }, 300);
    };

    closeOptimizationModalBtn.addEventListener('click', closeOptimizationModal);
    optimizationModalBackdrop.addEventListener('click', closeOptimizationModal);
    optimizationPortfolioNameEl.addEventListener('click', (e) => {
        if (e.target.classList.contains('copyable-strategy')) {
            const textToCopy = e.target.textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
                const originalColor = e.target.style.color;
                e.target.style.color = '#4ade80'; // green-400
                setTimeout(() => {
                    e.target.style.color = originalColor;
                }, 500);
            }).catch(err => {
                console.error('Error al copiar al portapapeles:', err);
            });
        }
    });

    const handleRowClick = (e) => {
        const row = e.target.closest('tr[data-row-type]');
        if (!row || e.target.closest('button') || e.target.matches('input, a, .copyable-strategy')) {
            return; // Ignorar clics en botones, inputs, links o elementos copiables
        }

        const type = row.dataset.rowType; // 'databank' or 'saved'
        const index = parseInt(row.dataset.rowIndex, 10);
        const selectionArray = selectedRows[type];

        const existingIndex = selectionArray.indexOf(index);
        if (existingIndex !== -1) {
            selectionArray.splice(existingIndex, 1); // Deseleccionar
        } else {
            selectionArray.push(index); // Seleccionar
        }

        // Redibujar la tabla correspondiente
        if (type === 'databank') updateDatabankDisplay();
        else if (type === 'saved') displaySavedPortfoliosList();
    };

    databankTableBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('copyable-strategy')) {
            const textToCopy = e.target.textContent;
            navigator.clipboard.writeText(textToCopy).then(() => {
                const originalColor = e.target.style.color;
                e.target.style.backgroundColor = '#10B981'; // green-500
                setTimeout(() => {
                    e.target.style.backgroundColor = '';
                }, 500);
            }).catch(err => {
                console.error('Error al copiar al portapapeles:', err);
            });
        }
        handleRowClick(e);
    });


    startSingleOptimizationBtn.addEventListener('click', async () => {
        toggleLoading(true, 'start-single-optimization-btn', 'start-optimization-btn-text', 'start-optimization-btn-spinner');
        optimizationResultsContainer.classList.add('hidden');
        
        await new Promise(resolve => setTimeout(resolve, 10)); // Allow UI to update
        
        try {
            const portfolio = savedPortfolios[currentOptimizationData.portfolioIndex];
            const numSimulations = parseInt(simulationsCountInput.value, 10);
            const targetMetric = optimizationTargetMetricSelect.value;
            const targetGoal = optimizationTargetGoalSelect.value;
            const minWeight = parseFloat(document.getElementById('min-weight-filter').value) / 100;

            const portfolioTradesData = portfolio.indices.map(index => rawStrategiesData[index]);
            
            let bestResult = {
                metric: (targetGoal === 'maximize' ? -Infinity : Infinity),
                weights: null,
                analysis: null,
                avgImprovement: -Infinity
            };

            const equalWeight = 1 / portfolioTradesData.length;
            if (equalWeight >= minWeight) {
                const equalWeights = Array(portfolioTradesData.length).fill(equalWeight);
                const weightedTrades = portfolioTradesData.flatMap((trades, i) => trades.map(trade => ({...trade, pnl: trade.pnl * equalWeights[i]})));
                const analysis = processStrategyData(weightedTrades, rawBenchmarkData);
                if (analysis) {
                    bestResult = { metric: analysis.metrics[targetMetric], weights: equalWeights, analysis, avgImprovement: 0 };
                }
            }

            const equalWeightedTradesForBase = [];
            portfolio.indices.forEach(index => {
                const weight = 1 / portfolio.indices.length;
                rawStrategiesData[index].forEach(trade => {
                    equalWeightedTradesForBase.push({ ...trade, pnl: trade.pnl * weight });
                });
            });
            const trueOriginalAnalysis = processStrategyData(equalWeightedTradesForBase, rawBenchmarkData);

            // The value to beat for the target metric
            const originalTargetMetricValue = trueOriginalAnalysis.metrics[targetMetric];

            const activeDatabankView = tableViews.databank[activeViews.databank] || tableViews.databank['default'];
            const metricsForBalance = activeDatabankView.columns.filter(key => key !== 'name' && key !== 'metricValue');

            let balancedBestResult = {
                metric: -Infinity, // We will store the avg improvement here
                weights: bestResult.weights,
                analysis: bestResult.analysis,
                avgImprovement: 0
            };


            for (let i = 0; i < numSimulations - 1; i++) {
                let weights = Array.from({ length: portfolio.indices.length }, () => Math.random());
                const sum = weights.reduce((a, b) => a + b, 0);
                weights = weights.map(w => w / sum);
                
                if (minWeight > 0 && weights.some(w => w < minWeight)) {
                    continue; // Skip this combination
                }

                const weightedTrades = [];
                 portfolioTradesData.forEach((strategyTrades, index) => {
                    strategyTrades.forEach(trade => {
                        weightedTrades.push({ ...trade, pnl: trade.pnl * weights[index] });
                    });
                });
                
                const analysis = processStrategyData(weightedTrades, rawBenchmarkData);
                
                if (analysis) {
                    const currentMetric = analysis.metrics[targetMetric];
                    
                    // 1. Check for best single metric
                    if ((targetGoal === 'maximize' && currentMetric > bestResult.metric) || (targetGoal === 'minimize' && currentMetric < bestResult.metric)) {
                        bestResult = { metric: currentMetric, weights: weights, analysis: analysis, avgImprovement: 0 }; // Improvement not needed here
                    }

                    // 2. Check for best balanced improvement, but only if it's better than the original on the target metric
                    const isBetterThanOriginalOnTarget = (targetGoal === 'maximize' && currentMetric >= originalTargetMetricValue) || (targetGoal === 'minimize' && currentMetric <= originalTargetMetricValue);

                    if (isBetterThanOriginalOnTarget) {
                        let totalImprovement = 0;
                        let improvementCount = 0;
                        metricsForBalance.forEach(metricKey => {
                            const originalValue = trueOriginalAnalysis.metrics[metricKey];
                            const optimizedValue = analysis.metrics[metricKey];
                            if (isFinite(originalValue) && isFinite(optimizedValue) && originalValue !== 0) {
                                const isMinimizing = ['maxDrawdown', 'downsideCapture', 'maxStagnationTrades', 'maxConsecutiveLosses', 'avgLoss', 'maxDrawdownInDollars', 'maxStagnationDays'].includes(metricKey);
                                const improvement = isMinimizing ? ((originalValue - optimizedValue) / Math.abs(originalValue)) * 100 : ((optimizedValue - originalValue) / Math.abs(originalValue)) * 100;
                                totalImprovement += improvement;
                                improvementCount++;
                            }
                        });

                        const avgImprovement = improvementCount > 0 ? totalImprovement / improvementCount : 0;
                        if (avgImprovement > balancedBestResult.metric) {
                            balancedBestResult = { metric: avgImprovement, weights: weights, analysis: analysis, avgImprovement: avgImprovement };
                        }
                    }
                }
            }

            const metricName = optimizationTargetMetricSelect.options[optimizationTargetMetricSelect.selectedIndex].text;
            displayOptimizationResults({
                baseAnalysis: trueOriginalAnalysis,
                metricBestAnalysis: bestResult.analysis,
                balancedBestAnalysis: balancedBestResult.analysis,
                portfolio: portfolio,
                metricBestWeights: bestResult.weights,
                balancedBestWeights: balancedBestResult.weights,
                optimizationMetricName: metricName
            });

        } catch (error) {
            console.error("Error during optimization:", error);
            displayError("Ocurri√≥ un error al optimizar los pesos.");
        } finally {
            toggleLoading(false, 'start-single-optimization-btn', 'start-optimization-btn-text', 'start-optimization-btn-spinner');
        }
    });
    
    const displayOptimizationResults = (results) => {
          const { 
              baseAnalysis, 
              metricBestAnalysis, 
              balancedBestAnalysis, 
              portfolio, 
              metricBestWeights, 
              balancedBestWeights, 
              optimizationMetricName 
          } = results;

          let tableRows = '';
          const metricsToDisplay = (tableViews.databank[activeViews.databank] || tableViews.databank['default']).columns.filter(key => key !== 'name' && key !== 'metricValue');
          metricsToDisplay.forEach(metricKey => {
               const metricInfo = ALL_METRICS[metricKey];
               if (!metricInfo || !baseAnalysis.metrics.hasOwnProperty(metricKey) || !metricBestAnalysis.metrics.hasOwnProperty(metricKey) || !balancedBestAnalysis.metrics.hasOwnProperty(metricKey)) return;

               const originalValue = baseAnalysis.metrics[metricKey];
               const metricOptimizedValue = metricBestAnalysis.metrics[metricKey];
               const balancedOptimizedValue = balancedBestAnalysis.metrics[metricKey];
               const isMinimizing = ['maxDrawdown', 'downsideCapture', 'maxStagnationTrades', 'maxConsecutiveLosses', 'avgLoss', 'maxDrawdownInDollars', 'maxStagnationDays'].includes(metricKey);
               
               const getImprovement = (optValue) => {
                   if (isFinite(originalValue) && isFinite(optValue) && originalValue !== 0) {
                       return isMinimizing ? ((originalValue - optValue) / Math.abs(originalValue)) * 100 : ((optValue - originalValue) / Math.abs(originalValue)) * 100;
                   }
                   return 0;
               };

               const metricImprovement = getImprovement(metricOptimizedValue);
               const balancedImprovement = getImprovement(balancedOptimizedValue);

               const formatImprovement = (improvement) => {
                   const color = improvement >= 0 ? 'text-green-400' : 'text-red-400';
                   const icon = improvement >= 0 ? '‚ñ≤' : '‚ñº';
                   return `<span class="${color}"><span>${icon}</span> <span>${Math.abs(improvement).toFixed(2)}%</span></span>`;
               };

               const isPercent = ['maxDrawdown', 'winningPercentage', 'upsideCapture', 'downsideCapture'].includes(metricKey);
               tableRows += `
                   <tr class="border-b border-gray-700">
                       <td class="p-2 font-semibold">${metricInfo.label}</td>
                       <td class="p-2 text-right">${isFinite(originalValue) ? originalValue.toFixed(2) + (isPercent ? '%' : '') : '‚àû'}</td>
                       <td class="p-2 text-right font-bold text-teal-300">${isFinite(metricOptimizedValue) ? metricOptimizedValue.toFixed(2) + (isPercent ? '%' : '') : '‚àû'}</td>
                       <td class="p-2 text-right font-bold text-sky-300">${isFinite(balancedOptimizedValue) ? balancedOptimizedValue.toFixed(2) + (isPercent ? '%' : '') : '‚àû'}</td>
                       <td class="p-2 text-right">${formatImprovement(metricImprovement)}</td>
                       <td class="p-2 text-right">${formatImprovement(balancedImprovement)}</td>
                   </tr>`;
          });
          
          const originalWeightsText = portfolio.indices.map(() => `${(100 / portfolio.indices.length).toFixed(0)}%`).join(' / ');
          const metricWeightsText = metricBestWeights.map(w => `${(w * 100).toFixed(0)}%`).join(' / ');
          const balancedWeightsText = balancedBestWeights.map(w => `${(w * 100).toFixed(0)}%`).join(' / ');
          
          const targetMetricName = optimizationMetricName || portfolio.riskConfig?.optimizationMetric || 'N/A';

           let html = `
               <h3 class="text-xl font-bold text-white mb-3">Resultados de Composici√≥n</h3>
               <div class="overflow-x-auto bg-gray-900/50 rounded-lg border border-gray-700">
                   <table class="w-full text-sm">
                       <thead class="bg-gray-700 text-xs text-gray-400 uppercase">
                           <tr>
                               <th class="p-2 text-left">M√©trica</th>
                               <th class="p-2 text-right">Original</th>
                               <th class="p-2 text-right">√ìptimo (M√©trica)</th>
                               <th class="p-2 text-right">√ìptimo (Balanceado)</th>
                               <th class="p-2 text-right">Mejora (M√©trica)</th>
                               <th class="p-2 text-right">Mejora (Balance)</th>
                           </tr>
                       </thead>
                       <tbody>${tableRows}</tbody>
                   </table>
               </div>`;
          
          // For risk scaling, we'll use the "Metric Best" as the reference for now.
          // This could be changed to a selector if needed.
          const baseMaxDDInDollars = metricBestAnalysis.metrics.maxDrawdownInDollars;
          const baseMaxDD95Confidence = baseMaxDDInDollars * 1.5;

          if (baseMaxDDInDollars > 0 && metricBestAnalysis) {
            html += `
                <div id="risk-scaling-container" class="mt-6 border-t border-gray-600 pt-6">
                    <h3 class="text-xl font-bold text-white mb-3">Escalar Riesgo por Max DD Objetivo</h3>
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700 text-center">
                            <span class="text-sm text-gray-400">Max DD Hist√≥rico (Actual): </span>
                            <span id="scaled-historical-dd-value" class="font-bold text-white">$${baseMaxDDInDollars.toFixed(2)}</span>
                        </div>
                        <div class="bg-gray-900/50 p-3 rounded-lg border border-gray-700 text-center">
                            <span class="text-sm text-gray-400">Max DD Objetivo (95% Confianza): </span>
                            <span id="max-dd-value" class="font-bold text-teal-300">$${baseMaxDD95Confidence.toFixed(0)}</span>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-4">
                        <input type="range" id="max-dd-slider" min="${Math.round(baseMaxDD95Confidence / 5)}" max="${Math.round(baseMaxDD95Confidence * 5)}" value="${baseMaxDD95Confidence.toFixed(0)}" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        <input type="number" id="max-dd-input" value="${baseMaxDD95Confidence.toFixed(0)}" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg w-28 p-2 text-center">
                    </div>
                    <div id="extra-risk-container" class="hidden mt-4">
                        <label for="extra-risk-slider" class="block text-sm font-semibold text-amber-400">Riesgo Extremo</label>
                        <input type="range" id="extra-risk-slider" min="0" max="${Math.round(baseMaxDD95Confidence * 5)}" value="0" class="w-full h-2 bg-amber-700 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <div class="mt-4 overflow-x-auto bg-gray-900/50 rounded-lg border border-gray-700">
                          <table class="w-full text-sm">
                              <thead class="bg-gray-700 text-xs text-gray-400 uppercase">
                                  <tr>
                                      <th class="p-2 text-left">Estrategia</th>
                                      <th class="p-2 text-right">Riesgo por Op. ($)</th>
                                  </tr>
                              </thead>
                              <tbody id="risk-scaling-table-body">
                              </tbody>
                          </table>
                      </div>
                </div>`;
          }
          
          const buttonText = 'Aplicar Cambios y Guardar';
          html += `<div class="mt-6 grid grid-cols-2 gap-x-4 gap-y-2">
                <button id="apply-metric-btn" class="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-3 rounded">Aplicar √ìptimo (M√©trica)</button>
                <button id="apply-balanced-btn" class="w-full bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-3 rounded">Aplicar √ìptimo (Balance)</button>
                <button id="save-new-metric-btn" class="w-full bg-teal-800 hover:bg-teal-900 text-white font-semibold py-1.5 px-3 rounded text-xs">Guardar como Nuevo (M√©trica)</button>
                <button id="save-new-balanced-btn" class="w-full bg-sky-800 hover:bg-sky-900 text-white font-semibold py-1.5 px-3 rounded text-xs">Guardar como Nuevo (Balance)</button>
            </div>`;
          
          const isOriginalAlreadySaved = savedPortfolios.some(p_ => 
              p_.indices.length === portfolio.indices.length && 
              p_.indices.every(i => portfolio.indices.includes(i)) && 
              !p_.weights
          );

          const areMetricWeightsEqual = metricBestWeights.every(w => Math.abs(w - (1 / portfolio.indices.length)) < 0.001);

          if (!areMetricWeightsEqual && !isOriginalAlreadySaved) {
              html += `<div class="mt-4">
                <button id="save-original-version-btn" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded text-sm">Guardar Versi√≥n Original (Pesos Iguales)</button>
              </div>`;
          }
          
          


           optimizationResultsContainer.innerHTML = html;
           optimizationResultsContainer.classList.remove('hidden');

           // --- EVENT LISTENERS FOR MODAL BUTTONS ---

           if (baseMaxDDInDollars > 0) {
               const slider = document.getElementById('max-dd-slider');
               const extraSlider = document.getElementById('extra-risk-slider');
               const extraRiskContainer = document.getElementById('extra-risk-container');
               const numberInput = document.getElementById('max-dd-input');
               const sliderValueEl = document.getElementById('max-dd-value');
               const riskTableBody = document.getElementById('risk-scaling-table-body');
               const scaledHistoricalDDValueEl = document.getElementById('scaled-historical-dd-value');
               
               const updateRiskScaling = () => {
                   const mainSliderValue = parseFloat(slider.value);
                   const extraSliderValue = parseFloat(extraSlider.value);
                   const targetDD95 = mainSliderValue + extraSliderValue;
                   
                   // Sincronizar input num√©rico
                   numberInput.value = targetDD95.toFixed(0);

                   // Actualizar visualizaci√≥n del valor
                   sliderValueEl.textContent = `$${targetDD95.toFixed(0)}`;
                   const scaleFactor = targetDD95 / baseMaxDD95Confidence;
                   
                   // Mostrar/ocultar slider de riesgo extremo
                   if (mainSliderValue >= slider.max) {
                       extraRiskContainer.classList.remove('hidden');
                   } else {
                       extraRiskContainer.classList.add('hidden');
                       extraSlider.value = 0; // Resetear si el slider principal no est√° al m√°ximo
                   }

                   // Colorear el valor objetivo seg√∫n el factor de escala
                   sliderValueEl.classList.remove('text-teal-300', 'text-amber-400', 'text-red-400');
                   if (scaleFactor > 2) sliderValueEl.classList.add('text-red-400');
                   else if (scaleFactor > 1) sliderValueEl.classList.add('text-amber-400');
                   else sliderValueEl.classList.add('text-teal-300');

                   // Actualizar DD hist√≥rico escalado
                   const scaledHistoricalDD = baseMaxDDInDollars * scaleFactor;
                   scaledHistoricalDDValueEl.textContent = `$${scaledHistoricalDD.toFixed(2)}`;

                   // Actualizar tabla de riesgo por operaci√≥n
                   let tableHtml = '';
                   portfolio.indices.forEach((strategyIndex, i) => {
                       const weight = metricBestWeights[i]; // Use metric-best weights for risk scaling display
                       const baseRisk = 100 * weight; // Basado en una "unidad de riesgo" de $100
                       const scaledRisk = baseRisk * scaleFactor;
                       const strategyName = loadedStrategyFiles[strategyIndex].name.replace('.csv', '');
                       tableHtml += `<tr class="border-b border-gray-700 last:border-b-0"><td class="p-2">${strategyName}</td><td class="p-2 text-right font-bold">${scaledRisk.toFixed(2)}</td></tr>`;
                   });
                   riskTableBody.innerHTML = tableHtml;
               };
               slider.addEventListener('input', () => { updateRiskScaling(); });
               extraSlider.addEventListener('input', () => { updateRiskScaling(); });
               numberInput.addEventListener('input', () => {
                   const val = parseFloat(numberInput.value);
                   const mainMax = parseFloat(slider.max);
                   if (val <= mainMax) {
                       slider.value = val;
                       extraSlider.value = 0;
                   } else {
                       slider.value = mainMax;
                       extraSlider.value = val - mainMax;
                   }
                   updateRiskScaling();
               });
               updateRiskScaling(); // Initial population
           }
          
           document.getElementById('save-original-version-btn')?.addEventListener('click', () => {
               const originalPortfolioData = {
                   name: `P${savedPortfolios.length + 1}: ${portfolio.name.replace(/ \(Opt.*?\)/, '').replace(' (Original)','')} (Original)`,
                   indices: portfolio.indices,
                   id: nextPortfolioId++,
                   weights: null, // No weights means equal weights
                   comments: ''
               };
               savedPortfolios.push(originalPortfolioData);
               reAnalyzeAllData();
               closeOptimizationModal();
               setTimeout(() => {
                   savedPortfoliosContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
               }, 400);
           });
          
           const savePortfolio = (isNew, weightsToSave, analysisToUse, nameSuffix) => {
               const slider = document.getElementById('max-dd-slider');
               let riskConfig = null;
               if (slider && analysisToUse.metrics.maxDrawdownInDollars > 0) {
                   const targetDD = parseFloat(document.getElementById('max-dd-input').value) || (analysisToUse.metrics.maxDrawdownInDollars * 1.5);
                   const scaleFactor = targetDD / (analysisToUse.metrics.maxDrawdownInDollars * 1.5);
                   riskConfig = {
                       scaleFactor: scaleFactor,
                       baseMaxDDInDollars: analysisToUse.metrics.maxDrawdownInDollars,
                       optimizationMetric: optimizationMetricName || portfolio.riskConfig?.optimizationMetric || 'N/A'
                   };
               }

               const baseName = portfolio.name.replace(/ \(Opt.*?\)/, '').replace(' (Original)', '');
               const newName = `${baseName} ${nameSuffix}`;

               const newPortfolioData = {
                   name: newName,
                   indices: portfolio.indices,
                   id: isNew ? nextPortfolioId++ : portfolio.id,
                   weights: weightsToSave,
                   riskConfig: riskConfig,
                   comments: isNew ? `Copia optimizada de '${portfolio.name}'.` : portfolio.comments || ''
               };

               if (isNew) {
                   savedPortfolios.push(newPortfolioData);
               } else {
                   savedPortfolios[currentOptimizationData.portfolioIndex] = newPortfolioData;
               }

               reAnalyzeAllData();
               closeOptimizationModal();
           };

           document.getElementById('apply-metric-btn').addEventListener('click', () => {
               savePortfolio(false, metricBestWeights, metricBestAnalysis, `(Opt. ${optimizationMetricName})`);
           });
           document.getElementById('apply-balanced-btn').addEventListener('click', () => {
               savePortfolio(false, balancedBestWeights, balancedBestAnalysis, `(Opt. Balanceado)`);
           });
           document.getElementById('save-new-metric-btn').addEventListener('click', () => {
               savePortfolio(true, metricBestWeights, metricBestAnalysis, `(Opt. ${optimizationMetricName})`);
           });
           document.getElementById('save-new-balanced-btn').addEventListener('click', () => {
               savePortfolio(true, balancedBestWeights, balancedBestAnalysis, `(Opt. Balanceado)`);
           });

    };
    
    const generateMonthlyPerformanceTable = (monthlyPerformance) => {
        if (!monthlyPerformance || Object.keys(monthlyPerformance).length === 0) return '';

        const years = Object.keys(monthlyPerformance).sort((a, b) => b - a);
        const months = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
        
        let headerHtml = '<tr><th class="p-2 text-left font-semibold">A√±o</th>';
        months.forEach(m => headerHtml += `<th class="p-2 text-right font-semibold">${m}</th>`);
        headerHtml += '<th class="p-2 text-right font-bold bg-gray-900/50">YTD</th></tr>';

        let bodyHtml = '';
        years.forEach(year => {
            const yearData = monthlyPerformance[year];
            let ytd = yearData.reduce((a, b) => a + b, 0);
            bodyHtml += '<tr class="border-t border-gray-700">';
            bodyHtml += `<td class="p-2 font-bold text-gray-300">${year}</td>`;
            for (let i = 0; i < 12; i++) {
                const value = yearData[i] || 0;
                const colorClass = value > 0 ? 'text-green-400' : (value < 0 ? 'text-red-400' : 'text-gray-500');
                bodyHtml += `<td class="p-2 text-right ${colorClass}">${value.toFixed(2)}</td>`;
            }
            const ytdColorClass = ytd > 0 ? 'text-green-300' : (ytd < 0 ? 'text-red-300' : 'text-gray-300');
            bodyHtml += `<td class="p-2 text-right font-bold bg-gray-900/50 ${ytdColorClass}">${ytd.toFixed(2)}</td>`;
            bodyHtml += '</tr>';
        });

        return `<div class="mt-6 col-span-1 lg:col-span-3">
                    <h3 class="text-xl font-bold text-white mb-3">Rendimiento Mensual ($)</h3>
                    <div class="overflow-x-auto bg-gray-800 rounded-lg border border-gray-700">
                        <table class="w-full text-sm whitespace-nowrap"><thead class="bg-gray-700 text-xs text-gray-400 uppercase">${headerHtml}</thead><tbody>${bodyHtml}</tbody></table>
                    </div>
                </div>`;
    };

    // --- FEATURED PORTFOLIO LOGIC ---
    const renderFeaturedPortfolio = () => {
        destroyChart('featured-portfolio-chart');
        if (featuredPortfolioIndex === null || !savedPortfolios[featuredPortfolioIndex]) {
            featuredPortfolioSection.innerHTML = '';
            featuredPortfolioSection.classList.add('hidden');
            return;
        }

        const portfolio = savedPortfolios[featuredPortfolioIndex];
        const portfolioAnalysis = window.analysisResults.find(r => r.isSavedPortfolio && r.savedIndex === featuredPortfolioIndex);
        if (!portfolioAnalysis) return;

        const { analysis } = portfolioAnalysis;
        const { metrics } = analysis;

        const metricsToShow = {
            'Sortino': isFinite(metrics.sortinoRatio) ? metrics.sortinoRatio.toFixed(2) : '‚àû',
            'Max DD (%)': `${metrics.maxDrawdown.toFixed(2)}%`,
            'Max DD ($)': `$${metrics.maxDrawdownInDollars.toFixed(0)}`,
            'Profit Factor': isFinite(metrics.profitFactor) ? metrics.profitFactor.toFixed(2) : '‚àû',
            'Profit/Mes': `$${metrics.monthlyAvgProfit.toFixed(0)}`,
            'Coef. Sharpe': isFinite(metrics.sharpeRatio) ? metrics.sharpeRatio.toFixed(2) : '‚àû',
            'Ratio Profit/DD': isFinite(metrics.profitMaxDD_Ratio) ? metrics.profitMaxDD_Ratio.toFixed(2) : '‚àû',
            'UPI': isFinite(metrics.upi) ? metrics.upi.toFixed(2) : '‚àû',
            'P√©rdidas Cons.': metrics.maxConsecutiveLosses,
            'Meses P√©rd. Cons. (Max)': metrics.maxConsecutiveLosingMonths.toFixed(0),
        };

        let metricsHtml = '';
        for (const [key, value] of Object.entries(metricsToShow)) {
            metricsHtml += `
                 <div class="bg-gray-800 p-3 rounded-xl text-center">
                     <h4 class="font-semibold text-gray-400 text-xs">${key}</h4>
                     <p class="text-xl font-bold">${value}</p>
                 </div>
            `;
        }

        const html = `
            <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl shadow-2xl p-6 border-2 border-amber-400">
                <h2 class="text-2xl font-bold text-amber-400 mb-4">‚≠ê Portafolio Destacado: ${portfolio.name}</h2>
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                    <!-- Metrics & Comments -->
                    <div class="lg:col-span-1 space-y-4">
                        <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-3 gap-2">
                            ${metricsHtml}
                        </div>
                         <div>
                             <label for="portfolio-comments" class="block text-sm font-semibold text-gray-300 mb-2">Comentarios</label>
                             <textarea id="portfolio-comments" rows="4" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm focus:ring-amber-500 focus:border-amber-500">${portfolio.comments || ''}</textarea>
                             <button id="save-comments-btn" class="mt-2 w-full bg-amber-500 hover:bg-amber-600 text-white font-bold py-2 px-4 rounded-lg text-sm">Guardar Comentarios</button>
                             <span id="save-comments-feedback" class="text-xs text-green-400 h-4 inline-block"></span>
                         </div>
                    </div>
                    <!-- Equity Chart -->
                    <div class="lg:col-span-2 bg-gray-800 p-4 rounded-xl">
                         <div class="h-64">
                             <canvas id="featured-portfolio-chart"></canvas>
                         </div>
                    </div>
                    ${generateMonthlyPerformanceTable(analysis.monthlyPerformance)}
                </div>
            </div>
        `;

        featuredPortfolioSection.innerHTML = html;
        featuredPortfolioSection.classList.remove('hidden');

        renderEquityChart('featured-portfolio-chart', analysis, portfolio.name, '#fbbf24'); // Usar color dorado para el destacado
        
        document.getElementById('save-comments-btn').addEventListener('click', () => {
            const comments = document.getElementById('portfolio-comments').value;
            savedPortfolios[featuredPortfolioIndex].comments = comments;
            const feedbackEl = document.getElementById('save-comments-feedback');
            feedbackEl.textContent = '¬°Guardado!';
            setTimeout(() => { feedbackEl.textContent = ''; }, 2000);
        });
    }

    // --- Chart Click Modal Logic ---
    const openChartClickModal = (savedIndex) => {
        portfolioActionTargetIndex = savedIndex;
        const portfolio = savedPortfolios[savedIndex];
        const modalTitle = document.getElementById('chart-click-modal-title');
        modalTitle.textContent = `Acciones para: ${portfolio.name}`;

        document.getElementById('feature-portfolio-checkbox').checked = (featuredPortfolioIndex === savedIndex);
        document.getElementById('delete-others-checkbox').checked = false;

        chartClickModal.classList.remove('hidden');
        chartClickModal.classList.add('flex');
        setTimeout(() => {
            chartClickModalBackdrop.classList.remove('opacity-0');
            chartClickModalContent.classList.remove('scale-95', 'opacity-0');
        }, 10);
    };

    const closeChartClickModal = () => {
        chartClickModalBackdrop.classList.add('opacity-0');
        chartClickModalContent.classList.add('scale-95', 'opacity-0');
        setTimeout(() => {
            chartClickModal.classList.add('hidden');
            chartClickModal.classList.remove('flex');
        }, 300);
    };

    chartClickCancelBtn.addEventListener('click', closeChartClickModal);
    chartClickModalBackdrop.addEventListener('click', closeChartClickModal);

    chartClickConfirmBtn.addEventListener('click', () => {
        const featureCheckbox = document.getElementById('feature-portfolio-checkbox').checked;
        const deleteCheckbox = document.getElementById('delete-others-checkbox').checked;

        if (portfolioActionTargetIndex !== null) {
            if (deleteCheckbox) {
                const portfolioToKeep = savedPortfolios[portfolioActionTargetIndex];
                savedPortfolios = [portfolioToKeep];
                // After filtering, the index of the kept portfolio will be 0
                featuredPortfolioIndex = featureCheckbox ? 0 : null; 
                comparisonPortfolioIndex = null;
            } else {
                 // Not deleting others
                if (featureCheckbox) {
                    featuredPortfolioIndex = portfolioActionTargetIndex;
                } else if (featuredPortfolioIndex === portfolioActionTargetIndex) {
                    // This is the un-featuring case
                    featuredPortfolioIndex = null;
                }
            }
        }
        
        reAnalyzeAllData();
        closeChartClickModal();
    });

    // --- VIEW MANAGER LOGIC ---
    const populateViewSelector = (viewSetKey) => {
        const selector = viewSetKey === 'databank' ? viewSelector : savedViewSelector;
        selector.innerHTML = '';
        for (const key in tableViews[viewSetKey]) {
            const view = tableViews[viewSetKey][key];
            const option = document.createElement('option');
            option.value = key;
            option.textContent = view.name;
            if (key === activeViews[viewSetKey]) {
                option.selected = true;
            }
            selector.appendChild(option);
        }
    };

    const openViewManager = (viewSetKey) => {
        currentEditingViewSet = viewSetKey;
        const visibleList = document.getElementById('visible-columns-list');
        const hiddenList = document.getElementById('hidden-columns-list');
        visibleList.innerHTML = '';
        hiddenList.innerHTML = '';

        const currentView = tableViews[currentEditingViewSet][activeViews[currentEditingViewSet]];
        const visibleKeys = new Set(currentView.columns);

        currentView.columns.forEach(key => {
            const colInfo = ALL_METRICS[key];
            if (colInfo) {
                visibleList.innerHTML += `<li class="p-2 bg-gray-700 rounded view-column-item" draggable="true" data-key="${key}">${colInfo.label.replace(/<div.*>(.*)<\/div>/, '$1')}</li>`;
            }
        });

        Object.keys(ALL_METRICS).forEach(key => {
            if (!visibleKeys.has(key) && key !== 'metricValue') { // Exclude 'metricValue' from saved portfolios hidden list
                const colInfo = ALL_METRICS[key];
                hiddenList.innerHTML += `<li class="p-2 bg-gray-700 rounded view-column-item" draggable="true" data-key="${key}">${colInfo.label.replace(/<div.*>(.*)<\/div>/, '$1')}</li>`;
            }
        });

        viewManagerModal.classList.remove('hidden');
        viewManagerModal.classList.add('flex');
        setTimeout(() => {
            viewManagerBackdrop.classList.remove('opacity-0');
            viewManagerContent.classList.remove('scale-95', 'opacity-0');
        }, 10);
    };

    const closeViewManager = () => {
        viewManagerBackdrop.classList.add('opacity-0');
        viewManagerContent.classList.add('scale-95', 'opacity-0');
        setTimeout(() => {
            viewManagerModal.classList.add('hidden');
            viewManagerModal.classList.remove('flex');
        }, 300);
    };

    manageViewsBtn.addEventListener('click', () => openViewManager('databank'));
    document.getElementById('saved-manage-views-btn').addEventListener('click', () => openViewManager('saved'));

    closeViewManagerBtn.addEventListener('click', closeViewManager);
    viewManagerBackdrop.addEventListener('click', closeViewManager);

    viewSelector.addEventListener('change', (e) => {
        activeViews.databank = e.target.value;
        updateDatabankDisplay();
    });

    document.getElementById('apply-view-btn').addEventListener('click', () => {
        const visibleColumns = Array.from(document.querySelectorAll('#visible-columns-list li')).map(li => li.dataset.key);
        tableViews[currentEditingViewSet][activeViews[currentEditingViewSet]].columns = visibleColumns;
        if (currentEditingViewSet === 'databank') {
            updateDatabankDisplay();
        } else {
            displaySavedPortfoliosList();
        }
        closeViewManager();
    });

    document.getElementById('save-view-btn').addEventListener('click', () => {
        const viewNameInput = document.getElementById('view-name-input');
        const newViewName = viewNameInput.value.trim();
        if (!newViewName) {
            alert('Por favor, introduce un nombre para la nueva vista.');
            return;
        }
        const newViewKey = newViewName.toLowerCase().replace(/\s+/g, '-');
        if (tableViews[currentEditingViewSet][newViewKey]) {
            if (!confirm(`Ya existe una vista llamada "${newViewName}". ¬øDeseas sobrescribirla?`)) {
                return;
            }
        }
        const visibleColumns = Array.from(document.querySelectorAll('#visible-columns-list li')).map(li => li.dataset.key);
        tableViews[currentEditingViewSet][newViewKey] = { name: newViewName, columns: visibleColumns };
        activeViews[currentEditingViewSet] = newViewKey;
        populateViewSelector(currentEditingViewSet);
        if (currentEditingViewSet === 'databank') {
            updateDatabankDisplay();
        } else {
            displaySavedPortfoliosList();
        }
        closeViewManager();
        viewNameInput.value = '';
    });

    document.getElementById('delete-view-btn').addEventListener('click', () => {
        const activeViewKey = activeViews[currentEditingViewSet];
        if (activeViewKey === 'default') {
            alert('No se puede eliminar la vista por defecto.');
            return;
        }
        if (confirm(`¬øEst√°s seguro de que quieres eliminar la vista "${tableViews[currentEditingViewSet][activeViewKey].name}"?`)) {
            delete tableViews[currentEditingViewSet][activeViewKey];
            activeViews[currentEditingViewSet] = 'default';
            populateViewSelector(currentEditingViewSet);
            if (currentEditingViewSet === 'databank') {
                updateDatabankDisplay();
            } else {
                displaySavedPortfoliosList();
            }
            closeViewManager();
        }
    });

    // Drag and Drop for View Manager
    let draggedItem = null;
    viewManagerModal.addEventListener('dragstart', (e) => {
        if (e.target.classList.contains('view-column-item')) {
            draggedItem = e.target;
            setTimeout(() => e.target.style.opacity = '0.5', 0);
        }
    });
    viewManagerModal.addEventListener('dragend', (e) => {
        if (draggedItem) {
            draggedItem.style.opacity = '1';
            draggedItem = null;
        }
    });
    viewManagerModal.addEventListener('dragover', (e) => {
        e.preventDefault();
    });
    viewManagerModal.addEventListener('drop', (e) => {
        e.preventDefault();
        const targetList = e.target.closest('ul');
        if (targetList && draggedItem) {
            const afterElement = getDragAfterElement(targetList, e.clientY);
            if (afterElement == null) {
                targetList.appendChild(draggedItem);
            } else {
                targetList.insertBefore(draggedItem, afterElement);
            }
        }
    });

    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // --- END VIEW MANAGER LOGIC ---

    // --- DATABANK TABLE SORT LISTENER ---
¬† ¬† const databankHeader = document.getElementById('databank-table-header');
¬† ¬† if (databankHeader) {
¬† ¬† ¬† ¬† databankHeader.addEventListener('click', (e) => {
¬† ¬† ¬† ¬† ¬† ¬† // Asegurarse de que el clic fue en un TH con clase 'sortable'
¬† ¬† ¬† ¬† ¬† ¬† const header = e.target.closest('th.sortable');
¬† ¬† ¬† ¬† ¬† ¬† if (header) {
¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† sortDatabank(header);
¬† ¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† });
¬† ¬† }
// --- DATABANK EVENT LISTENERS ---

    // Listener for the main search button
    findDatabankPortfoliosBtn.addEventListener('click', findDatabankPortfolios);

    // Pause/Resume button
    pauseSearchBtn.addEventListener('click', () => {
        isSearchPaused = !isSearchPaused;
        pauseSearchBtn.textContent = isSearchPaused ? 'Reanudar' : 'Pausar';
        // Status update is handled within the loop when paused
    });

    // Stop button
    stopSearchBtn.addEventListener('click', () => {
        isSearchStopped = true;
        stopSearchBtn.disabled = true; // Disable stop once clicked
        pauseSearchBtn.disabled = true; // Disable pause once stopped
        pauseSearchBtn.textContent = 'Pausar'; // Reset pause button text
        // Status update happens in the loop when it breaks
    });

    // Clear Databank button
    clearDatabankBtn.addEventListener('click', () => {
        databankPortfolios = [];
        isSearchPaused = false;
        isSearchStopped = false;
        databankStatus.innerHTML = 'DataBank limpiado.';
        updateDatabankDisplay();
        databankSection.classList.add('hidden'); // Optionally hide section when cleared
    });

    // Select All checkbox
    databankTableHeader.addEventListener('change', (e) => {
        if (e.target.id === 'databank-select-all') {
            const isChecked = e.target.checked;
            databankTableBody.querySelectorAll('.databank-row-checkbox').forEach(cb => {
                cb.checked = isChecked;
            });
        }
    });

    // Save Selected button
    databankSaveSelectedBtn.addEventListener('click', () => {
        const checkboxes = databankTableBody.querySelectorAll('.databank-row-checkbox:checked');
        let savedCount = 0;
        checkboxes.forEach(cb => {
            const index = parseInt(cb.dataset.index, 10);
            if (savePortfolioFromDatabank(index)) {
                savedCount++;
            }
        });
        if (savedCount > 0) {
            reAnalyzeAllData(); // Re-analyze only if something was actually saved
            alert(`‚úÖ Se guardaron ${savedCount} nuevo(s) portafolio(s).`);
            // Uncheck all after saving
            const selectAllCheckbox = document.getElementById('databank-select-all');
            if(selectAllCheckbox) selectAllCheckbox.checked = false;
            databankSelectAll.checked = false;
        } else {
             alert('‚ÑπÔ∏è No se guardaron nuevos portafolios (posiblemente ya exist√≠an).');
        }
    });

    // Event delegation for Save Single buttons within the table body
    databankTableBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('databank-save-single-btn')) {
            const index = parseInt(e.target.dataset.index, 10);
            if (savePortfolioFromDatabank(index)) {
                reAnalyzeAllData();
                alert(`‚úÖ Portafolio #${index + 1} guardado.`);
            } else {
                alert(`‚ÑπÔ∏è Este portafolio ya existe en la lista de guardados.`);
            }
        }
        // Uncheck "Select All" if any row checkbox is manually unchecked
        if (e.target.classList.contains('databank-row-checkbox') && !e.target.checked) {
             const selectAllCheckbox = document.getElementById('databank-select-all');
             if(selectAllCheckbox) selectAllCheckbox.checked = false;
         }
    });

    // --- END DATABANK EVENT LISTENERS ---


    // Initial Population
    savedPortfoliosBody.addEventListener('click', handleRowClick);
    populateViewSelector('databank');
    populateViewSelector('saved');

    // Quick Index Logic
    toggleQuickIndexBtn.addEventListener('click', () => {
        quickIndexContent.classList.toggle('hidden');
    });


});
</script>

</body>
</html>
